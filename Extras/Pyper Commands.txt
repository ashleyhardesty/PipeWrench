Pyper Commands

Following are all of the text filters that are included in Pyper.


AddValues           

syntax: AddValues [<char pos>...] /I<ins pos> /W<width> /D<decimals> /S                                                                 

adds two or more numbers found in each input line                                               

The AddValues filter adds two or more numbers found in each input line and outputs the result of the addition per each line. Each parameter supplied is the character position of a number to be added and in each case it must point at the left-most digit of the number to be added or at the white space prior to it. Alternately, if no parameters are specified then each input line of text is expected to contain numeric values separated by whitespace. If the /I switch is specified, the result of each addition is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.

Given input text containing the four columns of numbers,

 2.5       3.25      6.25      6.5
 3.5      12.5       4        10
----+----1----+----2----+----3----+----4----+----5

the pipe,

AddValues 1 11 21 31 

outputs the result of each addition:

 18.50 
 30.00
----+----1----+----2----+----3----+----4----+----5

Adding the /I switch,

AddValues 1 11 21 31 /i41

causes the result of the addition to be inserted back into each line, in this case at character position 41:

 2.5       3.25      6.25      6.5       18.50 
 3.5      12.5       4        10         30.00 
----+----1----+----2----+----3----+----4----+----5

See also SubValues, MultValues, DivValues


AppendStr           

syntax: AppendStr <string> /P                                                                                                           

concatenates the supplied string to the end of each line of the input text                      

The AppendStr filter concatenates the supplied string to the end of each line of the input text and then outputs the resulting lines. If the /P switch is specified then the string is instead pre-pended to each line of the input text.

Given the following list of files (minus file extensions),

convert
this
that
theother

the pipe,

AppendStr '.bat' /b

will output:

convert.bat
this.bat
that.bat
theother.bat

This next example illustrates how to insert a line of text using the AppendStr filter in combination with text isolation. Given the following text,

this is line 1
this is line 3
this is line 4

IsolateLines 'line 1'
  AppendStr '\ethis is line 2'
EndIsolate

will output:

this is line 1
this is line 2
this is line 3
this is line 4

See also InsStr


BaseToDec           

syntax: BaseToDec <radix> /I<ins char pos> /S<scan char pos> /W<width> /Z                                                               

converts numbers of the given base found in the input text to decimal                           

The Base2Dec filter converts whole numbers of the given base, (2 - 62) found in the input text to decimal, (base 10) and then outputs the resulting values. The only required parameter is the radix of the numeric values found in the input text. If an insert character position is specified using the /I switch the resulting decimal value will be inserted into the output text at the specified character position rather than being output alone. The /S switch can be used to specify the character position where scanning for the input values begins. If the /S switch is omitted, scanning begins at character position 1. The /W switch determines the width of the numeric result. The default is 6. The /Z switch causes the value(s) to be displayed with leading zeros.  

The characters read from standard input must follow the numerical sequence (dependent on radix):

"0" - "9", "A" - "Z", "a" - "z" 

Because this sequence contains both upper and lower case characters, case is obviously significant when considering numbers to be converted.  As such, even if they were of the same base, the values "f2ac" and "F2AC" would not be equivalent!  

To illustrate the Base2Dec filter, the binary value, 

10011

run through the pipe,

Base2Dec 2

will output:

    19
----+----1----+----2

The Base2Dec filter can be used in conjunction with the Dec2Base filter to perform base conversions from one base to another assuming that they are both in the range, (2 - 62).  See the Dec2Base filter for an example of how this is done.  

See also Dec2Base


BottomLines         

syntax: BottomLines <no of lines>                                                                                                         

outputs the given number of lines from the end of the text                                      

The BottomLines filter outputs the given number of lines from the bottom of the input text. It can be used in conjunction with the TopLines filter to return a range of lines from the middle of the input text. For example, given the following input text,

this is line 1
this is line 2
this is line 3
this is line 4

the pipe,

TopLines 3 
BottomLines 2 

will output:

this is line 2
this is line 3

For another way of returning a range of lines, see the LinesByPos filter.

See also TopLines, LinesByPos


Call                

syntax: Call <pipe file name> [<arg>...]                                                                                           

calls a pipe from the currently executing pipe                                                  

The Call command is used to invoke or call another pipe from the currently executing pipe. It takes as its first argument a single-quoted string that represents the called pipe's filename:

Call 'c:\pipes\mypipe.pip' ...

Just like with filters, pipes can accept arguments and switches. In a Call command, any such arguments or switches that follow the called pipe's filename are passed to the called pipe. The arguments and switches that are expected by a called pipe is determined by its template. This template is recorded in the comment block at the top of the pipe (its "header"). To illustrate the calling of a pipe, we start with a pipe that's been saved to disk as "Envelop.pip":

; Name: Envelop.pip
; Template: s s
;
; This pipe envelops each line
; inside the given two strings.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

InsStr 1 '[1]' 
AppendStr '[2]'

As you can see, the pipe's template is "s s". This tells Pyper that the pipe requires two string arguments. It could therefore be called from another pipe as shown here:

; Name: MainPipe.pip
;
; This pipe parses the given text onto 
; separate lines, envelops each line 
; inside two strings and then uppercases 
; the text.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ParseWords 
Call 'Envelop.pip' '<<<' '>>>'
UpperCase

Note: If the called pipe is referenced without a path, (i.e. "mypipe.pip") it must exist in the same folder as the calling pipe.


CenterText          

syntax: CenterText <field width>                                                                                                         

centers the input text in a field of the given character width                                  

The CenterText filter centers the input text in a field of the given character width by padding on the left with the appropriate number of blank characters.  

Given the input text, 

This
Is
Centered

The pipe, 

CenterText 50  

results in:

                       This
                        Is
                     Centered
----+----1----+----2----+----3----+----4----+----5


ColumnOrder         

syntax: ColumnOrder <no of rows> <no of columns>                                                                                          

a pre-filter to the JoinLines filter which allows columns to be ordered down instead of across  

The ColumnOrder filter is used as a pre-filter to the JoinLines filter so that the text stream can be reformed into columns that are ordered top to bottom instead of being ordered left to right as would normally be output from the JoinLines filter, given a sorted list of items. The first parameter required is the number of rows that you wish to limit the table to. The second is the number of columns.  

To illustrate, suppose you wanted to format a list of unordered names into 3 columns, ordered. Given the list of unordered names,

pat
jim
cindy
ernie
stephanie
brian
bert
susan
randy
leonard
philip
terry
kathy
evan
jacob

the pipe,

SortLines 
PadLinesRight ' ' /w15
JoinLines 3

will output three columns of names:

bert           brian          cindy          
ernie          evan           jacob          
jim            kathy          leonard        
pat            philip         randy          
stephanie      susan          terry          
----+----1----+----2----+----3----+----4----+----5

Notice that the names are ordered across the columns, from left to right. Had we intended for them to be ordered down each column instead, we would need to apply the ColumnOrder filter ahead of the JoinLines filter:

SortLines 
PadLinesRight ' ' /w15
ColumnOrder 5 3 
JoinLines 3

This produces three columns of names that are ordered down each column:

bert           jacob          philip         
brian          jim            randy          
cindy          kathy          stephanie      
ernie          leonard        susan          
evan           pat            terry          
----+----1----+----2----+----3----+----4----+----5

Note: The number of lines being joined by the JoinLines filter must be the same as the number of columns specified in the ColumnOrder filter.  

As a second example of using the ColumnOrder filter, suppose you had a list of names and addresses that you needed to create mailing labels from:

Jim Philips              1290 Pin Oak Ln          Westhaven, FL 77392
Ted Crowder              7382 West 21st St.       Lincoln, AR 72882
Lisa Taylor              1213 Pompano St.         Norden, TX 77283
Laura Michelson          1550 Fenn Way Blvd.      Treeville, CO 77662
Peter Piper              8399 Fourth St.          Ashton, CT 72882
William Orson            7113 France Ave.         Linden KY 66383
Susan Simpson            728 Conner Peak St.      Freemont IN, 45892
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----

If your label stock is one label wide, you could simply execute the following pipe,

AppendStr '\e' 
SplitLines 26 51

to obtain the desired output:

Jim Philips
1290 Pin Oak Ln
Westhaven, FL 77392

Ted Crowder
7382 West 21st St.
Lincoln, AR 72882

Lisa Taylor
1213 Pompano St.
Norden, TX 77283

Laura Michelson
1550 Fenn Way Blvd.
Treeville, CO 77662

Peter Piper
8399 Fourth St.
Ashton, CT 72882

...

The AppendStr filter is used to first double-space the list of names and the SplitLines filter then splits each line into three separate lines. Note that the SplitLines filter doesn't affect the blank lines as their length, (0) is less than the column positions 26 and 51 at which splitting takes place.

Now, suppose you wanted the labels to be printed on a laser printer, 3 across by say, 15 deep per page. Adding three more filters to the original pipe gives us the pipe:

AppendStr '\e' 
SplitLines 26 51
PadLinesRight ' ' /w25
ColumnOrder 12 3 
JoinLines 3 

Its execution delivers the following output:

Jim Philips              Laura Michelson          Susan Simpson            
1290 Pin Oak Ln          1550 Fenn Way Blvd.      728 Conner Peak St.      
Westhaven, FL 77392      Treeville, CO 77662      Freemont IN, 45892       
                                                                           
Ted Crowder              Peter Piper              
7382 West 21st St.       8399 Fourth St.          
Lincoln, AR 72882        Ashton, CT 72882         
                                                  
Lisa Taylor              William Orson            
1213 Pompano St.         7113 France Ave.         
Norden, TX 77283         Linden KY 66383          

----+----1----+----2----+----3----+----4----+----5----+----6----+----7

In this particular example, I limited the output to 3 labels deep by specifying 12 rows in the ColumnOrder filter instead of the 28 that would be required for a single column, (7 labels x 4 lines per label). This allowed the output to span 3 columns for the sake of demonstration.


CountChars          

syntax: CountChars /I<char pos> /L /W<width> /Z                                                                                          

outputs the number of characters                                                                

The CountChars filter outputs the total number of characters in the input text. If the /L switch is specified then the total number of characters per each line is output instead. If the /I switch is specified along with the /L switch then each line's total is inserted back into the line at the specified character position. The /W switch determines the width of the resulting numeric value(s) and the /Z switch causes them to be displayed with leading zeros. Given the following text,

The CountChars filter
outputs the total number
of characters in
the input text.

the pipe,

CountChars

will return:

    76
----+----1----+----2

Note: If the /I switch is specified without the /L switch, it will be ignored.

See also CountLines


CountLines          

syntax: CountLines /W<width> /Z                                                                                                          

outputs the number of lines                                                                     

The CountLines filter outputs the total number of lines in the input text. The /W switch determines the width of the resulting numeric value and the /Z switch causes the count to be displayed with leading zeros. Given the following text,

The CountLines filter
outputs the total number
of lines in
the input text.

the pipe,

CountLines /w3 /z

will return:

004
----+----1----+----2

See also CountChars


CullLines           

syntax: CullLines <begin string> <end string> /A /I /R                                                                                  

removes groups of lines encountered in the input text                                           

The CullLines filter removes from output the first group of lines encountered in the input text in which the initial line of the group contains the <begin string> and the last line of the group contains the <end string>. If the /A switch is specified, all such groups encountered in the input text will be removed. If the /I switch is specified, case is ignored in locating the "boundary" strings in the input text. If the /R switch is specified the strings are treated as regular expression patterns. If both strings are found on the same line, then only that line will be removed. Given the following text, 

the
quick brown
fox
jumped
over the lazy
dog and
the lazy
dog
didn't even bark
----+----1----+----2

the pipe,

CullLines 'fox' 'lazy' 

will result in:

the
quick brown
dog and
the lazy
dog
didn't even bark
----+----1----+----2

Note: The CullLines filter performs the opposite function of the ExtractLines filter which outputs the text between the two strings instead of removing the text.

See also ExtractLines


DecToBase           

syntax: DecToBase <radix> /I<ins char pos> /S<scan char pos> /W<width> /Z                                                               

converts decimal numbers found in the input text to another base                                

The Dec2Base filter converts decimal, (base 10) numbers found in the input text to another base, (2 - 62) and then outputs the resulting values. The only required parameter is the radix of the numbers being converted to. If an insert character position is specified using the /I switch the resulting decimal values will be inserted into the output text at the specified character position rather than being output alone. The /S switch can be used to specify the character position where scanning for the input (decimal) values begins. If the /S switch is omitted, scanning begins at character position 1. The /W switch determines the width of the numeric result. The /Z switch causes the value(s) to be displayed with leading zeros.  

Given a single input line of text containing the characters "255" (a decimal value), the following pipe will convert it to  "FF", (base 16 or hexadecimal):

Dec2Base 16

As the filters, Base2Dec and Dec2Base can convert to and from decimal, they can be combined to allow conversion from any base to any other base, (2 - 62).  For example, the following pipe could be used to convert the value "1010" (in binary) to "A" (hexadecimal):

Base2Dec
Dec2Base 16

See also Base2Dec


DelBlankLines       

syntax: DelBlankLines 

removes blank lines from output                                                                 

The DelBlankLines filter filters all blank lines. A blank line is considered to be one that contains no characters. A line containing just blank or tab characters is NOT considered a blank line. In order to remove lines containing only blank or tab characters, the TrimLines or TrimLinesRight filters must first be used to remove the whitespace.  

Given the following 3 lines of text -- the 2nd of which is blank,

This line is not blank
	
This line is also not blank

...the pipe, 

DelBlankLines 

...will output the non-blank lines only:

This line is not blank
This line is also not blank

See also DelExtraBlankLines 


DelChars            

syntax: DelChars <char pos> <no of chars> [<char pos> <no of chars>...]                                                                

deletes characters from each line at specified character positions                              

The DelChars filter deletes a specified number of characters from each line at a given character position. Multiple deletions may be performed, however the position parameters must be in ascending order.

To illustrate the DelChars filter, suppose you wanted to delete the 2nd and 4th columns from the following fixed-width data:

54667  Tiny Tim     05/05/1980  M   20456.45   2347281749
87896  John Doe     01/15/1960  M   234888.56  6482610982
98798  Lex Luther   05/26/1940  M   9834.01    4566281737
67491  Betty Boop   05/26/1932  F   34772.01   1902630722
----+----1----+----2----+----3----+----4----+----5----+----6

The pipe, 

DelChars 8 13 33 4

delivers the desired results:

54667  05/05/1980  20456.45   2347281749
87896  01/15/1960  234888.56  6482610982
98798  05/26/1940  9834.01    4566281737
67491  05/26/1932  34772.01   1902630722
----+----1----+----2----+----3----+----4----+----5----+----6

Note: To reorder the columns in addition to removing some of them, see the SubStr filter.

See also StripChars, SubStr


DelCharsToStr       

syntax: DelCharsToStr <string> /I /N<count> /R                                                                                              

deletes characters until string is encountered                                                  

???


DelDuplLines        

syntax: DelDuplLines [<char pos> <char pos>] /A /D<delimiter> /I                                                                           

acts on sorted lists removing all duplicate lines                                               

The DelDuplLines filter acts on sorted lists, removing any extraneous duplicate lines (thus, outputting only a single line for each set of duplicate lines). If the /A switch is added, all lines are removed from each set of duplicate lines. If the /I switch is specified, case is ignored in determining uniqueness. If a delimiter is specified using the /D switch, then duplication is based on the text at the beginning of each line up to the delimiter. You can also specify a range of character positions upon which duplication is determined. See the OutDuplLines filter for an example use of the DelDuplLines filter.

Note: In order for the DelDuplLines filter to work, the input text must be sorted. If removing duplicates based on a range of character positions, the input text must be sorted on that same range of character positions.

Note: Either a range or a delimiter should be specified, but not both.

See also SortLines, OutDuplLines,


DelExtraBlankLines  

syntax: DelExtraBlankLines 

removes extraneous blank lines                                                                  

The DelExtraBlankLines filter removes extraneous blank lines. It replaces any number of consecutive blank lines with a single one. Note that to be considered blank, a line must contain absolutely no characters, not even blanks or tab characters; therefore, it may be necessary to remove trailing blanks and tabs from all lines first, (using either the TrimLines or TrimLinesRight filters) before the DelExtraBlankLines filter is used.

See also DelBlankLines


DelExtraBlanks      

syntax: DelExtraBlanks 

removes extraneous blanks from each line                                                        

The DelExtraBlanks filter removes all extraneous blanks from each line. It replaces any number of consecutive blanks with a single one. 

Note: The DelExtraBlanks has no effect on tab characters.


DivValues           

syntax: DivValues <char pos> <char pos> /I<ins char pos> /W<width> /D<decimals> /S                                                      

performs division with two numbers in the input text                                            

The DivValues filter divides two numbers found in each input line and outputs the result of the division per each line. The two required parameters specify at what character positions the numbers involved in the division are located and in each case must point at the leftmost digit of the number or at the white space prior to it. If the /I switch is specified, the result of the division is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.

Given input text containing the two columns of numbers:

100  20
20    5
----+----1----+----2

the pipe,

DivValues 1 5

will result in:

  5.00
  4.00
----+----1----+----2

Adding the /I switch,

DivValues 1 5 /i10

causes the result of the division to be inserted back into each line, in this case at character position 10:

100  20    5.00 
20    5    4.00 
----+----1----+----2


EndIsolate          

syntax: EndIsolate 

used with IsolateLines to constrain pipe commands to an isolated block of text

The EndIsolate filter is used along with IsolateLines to constrain pipe commands to isolated block of text.

???


ExclLines           

syntax: ExclLines <string> [<begin char pos> <end char pos>] /I /R                                                                      

excludes all lines from output that contain the specified string                                

The Excllines filter filters all lines that contain the specified string. If the optional range of character positions is specified, then lines are excluded only if the string exists within that range of character positions. If the /I switch is specified then the case of the string is ignored. If the /R switch is specified the string is treated as a regular expression pattern.

For example,

ExclLines 'the' 5 7 

...will remove all lines from output that contain the string 'the' in character positions 5 through 7. 

Note: The InclLines filter performs the opposite function of ExclLines.

See also InclLines


ExtractLines        

syntax: ExtractLines <begin string> <end string> /A /I /R                                                                                  

extracts groups of lines encountered in the input text                                          

The ExtractLines filter extracts the first group of lines encountered in the input text in which the initial line of the group contains the <begin string> and the last line of the group contains the <end string>. If the /A switch is specified, all such groups encountered in the input text will be extracted. If the /I switch is specified, case is ignored in locating the "boundary" strings in the input text. If the /R switch is specified the strings are treated as regular expression patterns. If both strings are found on the same line, then only that line will be extracted. Given the following text, 

the
quick brown
fox
jumped
over the lazy
dog and
the lazy
dog
didn't even bark
----+----1----+----2

the pipe,

ExtractLines 'fox' 'lazy' 

will result in:

fox
jumped
over the lazy
----+----1----+----2

Note: The ExtractLines filter performs the opposite function of CullLines which removes the text between the two strings instead of passing the text.

See also CullLines


FoldLines           

syntax: FoldLines [<char pos> <char pos>] /D<delimiter> /E /I /J<join opt> /W<width> /Z                                                 

acts on sorted lists folding duplicate lines                                                    

The FoldLines filter acts on sorted lists, folding any duplicate lines (outputting just a single line for each group of duplicate lines along with an appended count). If a range of character positions is specified then uniqueness is determined based on that range only. Likewise, if a delimiter character is specified using the /D switch, uniqueness is determined based on the text found at the beginning of each line up to the delimiter. If the /I switch is specified, case is ignored in determining uniqueness. If the /E switch is specified, input lines are expected to already have a count appended (by default, input lines have an implicit count of "1"). A join option can be specified using the /J switch. A join option of 0 (the default) causes output of a single line plus a count for each group of duplicate lines. Use of join option causes each group of duplicate lines to be joined onto one line. Join option 2 simply combines join options 0 and 1.

Note: In order for the FoldLines filter to work, the input text must be sorted. If folding duplicates based on a range of character positions, the input text must be sorted on that same range of character positions.

Note: Either a range or a delimiter should be specified, but not both.

See also JoinLines


GroupLines          

syntax: GroupLines <string> [<begin char pos> <end char pos>] /I /R                                                                      

groups lines together that contain a string                                                     

???


InclLines           

syntax: InclLines <string> [<begin char pos> <end char pos>] /I /R                                                                      

includes all lines in the output that contain the specified string                              

The InclLines filter outputs all lines that contain the specified string. If the optional range of character positions is specified, then lines are output only if the string exists within that range of character positions. If the /I switch is specified then the case of the string is ignored. If the /R switch is specified the string is treated as a regular expression pattern.

Forexample, the pipe,

InclLines 'the' 5 7 

...will output all lines that contain the string 'the' in character positions 5 through 7. 

Note: The ExclLines filter performs the opposite function of InclLines.

See also ExclLines


InsLineNo           

syntax: InsLineNo /L<init no> /I<incr> /P<ins pos> /S<no of lines> /W<width> /Z                                                         

inserts a line number at the specified character position of each line                          

The InsLineNo filter inserts a line number into each line. The line number is inserted at the beginning of each line unless the /P switch specifies that the line number is to be inserted at another character position. You can use the /L switch to specify the initial line number which can be a negative number. By default it is 1. Specify a /I switch if you want the line numbers to increment by some integer value other than the default which is 1, (it can be a negative number as well). Specify a /S switch if you want the line number sequence to repeat every specified number of lines. The default is 0 meaning that no repetition occurs. The /W switch determines the width of each line number. If not specified, the default numeric width, 6 is used. If the /Z switch is specified, the line numbers will be left-padded with zeros.  

As an example, supposed we had the following list of names,

John
Susan
Paul
George
----+----1----+----2

... and for whatever reason, we wanted to vertically "flip" them. This is easily done using the InsLineNo filter in combination with SortLines:

InsLineNo /w6 /z
SortLines /r
DelChars 1 6

Execution of this pipe results in the expected output:

George
Paul
Susan
John

Note: The InsLineNo filter is typically used as a pre-filter to record the current "order" of the input text prior to subsequent processing by other filters which may reorder the text as part of their processing. This allows the lines of text to later be sorted back to their original order. For an example where the InsLineNo filter is used for this purpose see the IsolateLines filter.


InsStr              

syntax: InsStr <char pos> <string> [<char pos> <string>...]                                                                          

inserts character strings into each line at specified character positions                       

The InsStr filter inserts a character string into each line at the specified character position. Multiple insertions into each line may be performed however the character position parameters must be in ascending order.

Given the following list of batch files,

convert.bat
this.bat
that.bat
theother.bat
----+----1----+----2----+----3----+----4----+----5

the pipe,

InsStr 1 'c:\\temp\\' 15 '"a command line argument"'

will output:

c:\temp\convert.bat   "a command line argument"
c:\temp\this.bat      "a command line argument"
c:\temp\that.bat      "a command line argument"
c:\temp\theother.bat  "a command line argument"
----+----1----+----2----+----3----+----4----+----5

See also AppendStr, OverlayChars


IsolateLines        

syntax: IsolateLines <string> [<begin char pos> <end char pos>] /Es /I /R                                                                  

used along with EndIsolate to constrain pipe commands to isolated block of text                 

To illustrate text isolation, suppose we had three "records" of data, each one consisting of 4 fields: name, age, city and state, all contained on separate lines:

John L. Doe
42
Miami
FL
Frank N. Stein
20
Los Angeles
CA
Norma Lee
16
Austin
TX
----+----1----+----2

Now, suppose we wanted to uppercase just those lines containing the person's name, leaving all of the other lines unchanged. This is a simple matter although it requires that the targeted text be isolated first. Text isolation takes advantage of the fact that the targeted lines are somehow distinguishable from other lines. To this end, our first order of business is to use the InsLineNo filter to add line numbers (that repeat every four lines) to the lines of text. This will later allow us to isolate all of those lines that begin with a "1". 

InsLineNo /w1 /s4

Next, since text isolation changes the line order of the text, we must use the InsLineNo filter again--this time to record the line order of the current text. Here, the line number doesn't repeat and its 2 characters wide with leading zeros.

InsLineNo /w2 /z

Now we're almost ready to isolate the text; however, text isolation only works if the targeted lines (those being isolated) are grouped together in the text. Here, we use the GroupLines filter to group all lines that begin with a "1" at the end of the text.

GroupLines '1' 3 3

Now we can isolate the targeted text. This is done simply by specifying the IsolateLines filter with the same arguments as the GroupLines filter did prior.

IsolateLines '1' 3 3

At this point the tageted lines are isolated. In other words, any filters enclosed inside of the IsolateLines and EndIsolate filters will only operate on these targeted lines of text. As such, all we need to do now is apply the UpperCase filter:

UpperCase

Although the targeted lines are now uppercased like we wanted, they now must be integrated back into the original text. This is done by use of the EndIsolate filter.

EndIsolate

The targeted lines are now integrated into the original text but they are still grouped at the end of it. By sorting the text the edited lines are "ungrouped" back to their original positions:

SortLines

Finally, we remove the double line numbers that were added at the beginning and we're done:

DelChars 1 3

Here's the completed pipe,

InsLineNo /w1 /s4
InsLineNo /w2 /z
GroupLines '1' 3 3
IsolateLines '1' 3 3
   UpperCase
EndIsolate
SortLines
DelChars 1 3

... and its resulting output:

JOHN L. DOE
42
Miami
FL
FRANK N. STEIN
20
Los Angeles
CA
NORMA LEE
16
Austin
TX
----+----1----+----2

Note: As you may have guessed, it's possible using this technique to edit a single "column" of the input text as well. One merely has to translate the columns into rows first (for example, by using the SplitLines filter) and then, after the editing is done, translate the rows back to columns.  For example, given the text,

smoky   bear    says    
only    you     can
prevent forest  fires
----+----1----+----2

... you could use the following pipe to uppercase just those words that are in column two--"bear", "you" and "forest" (try it):

SplitLines 9 17 
InsLineNo /w1 /s3
InsLineNo /w2 /z
GroupLines '2' 3 3
IsolateLines '2' 3 3
   UpperCase
EndIsolate
SortLines
DelChars 1 3
JoinLines 3 

The resulting text is:

smoky   BEAR    says    
only    YOU     can
prevent FOREST  fires


JoinLines           

syntax: JoinLines [<no of lines>] /P                                                                                                    

joins every n lines of text into a single line of text                                          

The JoinLines filter combines all lines in the input text onto a single line, in-effect removing all end-of-lines from the input text. If the optional number of lines parameter is specified then that many lines will be combined onto each line output. The /P switch is used to join all of the lines within each "paragraph" (a sequence of non-blank lines) onto a single line and is ignored if the <number of lines> parameter is specified. 

Warning: JoinLines is the key to some of the more advanced piping techniques; however, be forewarned that it is VERY costly from a performance perspective. Try to limit the number of lines of text that are input to the JoinLines filter whenever possible by filtering unneeded text lines prior to its execution.

To illustrate use of JoinLines, consider the following text which represents three data records, each containing a name, age, city and state:

John L. Doe
42
Miami
FL
Frank N. Stein
20
Los Angeles
CA
Norma Lee
16
Austin
TX
----+----1----+----2----+----3----+----4

Normally, you wouldn't encounter data records in this form; however, it is quite common to do so when working with pipes. To transform the above text to the more conventional form, you'd employ the following pipe:

AppendStr ','
JoinLines 4
StripChars 1

When executed, it results in the following comma-delimited data:

John L. Doe,42,Miami,FL
Frank N. Stein,20,Los Angeles,CA
Norma Lee,16,Austin,TX
----+----1----+----2----+----3----+----4

Note: For a more practical example in which fixed-width data is translated to comma-delimited data (which uses the JoinLines filter), see the QuoteLines filter.

Next up, given you have multiple paragraphs of text:

This is the
first paragraph of text
contained on three lines.

This is the second
paragraph of text contained on two lines.

This is the third paragraph of text contained on one line.

Suppose you want to remove all end-of-lines from each paragraph. The following pipe does the trick:

AppendStr ' '
JoinLines /p

When run, it outputs:

This is the first paragraph of text contained on three lines. 

This is the second paragraph of text contained on two lines. 

This is the third paragraph of text contained on one line. 

Note: For an example in which the JoinLines filter is used to create multiple columns of text from a single column, see the ColumnOrder filter.


JustCharsLeft       

syntax: JustCharsLeft [<begin char pos> <end char pos>]                                                                                     

left justifies characters                                                                       

The JustCharsLeft filter left-justifies each line of text. If the optional range of character positions is specified, the filter operates only on that range of characters. For an example of how this works, see JustCharsRight.

See also JustCharsRight.


JustCharsRight      

syntax: JustCharsRight [<begin char pos> <end char pos>]                                                                                     

right justifies characters                                                                      

The JustCharsRight filter right-justifies each line of text. If the optional range of character positions is specified, the filter operates only on that range of characters. The JustCharsRight filter can be used in combination with the PadLinesRight filter to right-justify entire lines:

PadLinesRight ' '
JustCharsRight

Optionally, JustCharsRight can justify a range of character positions. For example, if you wanted to right-justify just the folder names in the following text,

06/02/2002  02:39p  <dir>  Documents and Settings  Archived
10/28/2002  10:16a  <dir>  Outlook Mail Messages   Archived
05/12/2003  05:52p  <dir>  Program Files           Archived
04/14/2003  08:36a  <dir>  Trash                   Archived
04/01/2003  01:55p  <dir>  WINNT                   Archived

... you could call JustCharsRight like this:

JustCharsRight 28 49

This would result in the following:

06/02/2002  02:39p  <dir>  Documents and Settings  Archived
10/28/2002  10:16a  <dir>   Outlook Mail Messages  Archived
05/12/2003  05:52p  <dir>           Program Files  Archived
04/14/2003  08:36a  <dir>                   Trash  Archived
04/01/2003  01:55p  <dir>                   WINNT  Archived

The text can easily be restored back to original by passing it through the JustCharsLeft filter like this:

JustCharsLeft 28 49

See also JustCharsLeft.


LeftChars           

syntax: LeftChars <no of chars>                                                                                                         

returns the given number of characters from the beginning of each line of text                  

The LeftChars filter outputs the specified left-most characters from each input line of text. 

Given the text,

123.45, Table
061.22, Chair
----+----1----+----2

the pipe,

LeftChars 6

gives:

123.45
061.22
----+----1----+----2

See also RightChars


LinesByPos          

syntax: LinesByPos <begin line> <end line> [<begin line> <end line>...] /S<no of sets>                                                   

outputs lines according to their position                                                       

The LinesByPos filter outputs those lines that fall within the specified range of lines. Multiple ranges can be specified but they must be in asending order. For example, 1 3 7 10 16 16 would result in output of lines 1-3, 7-10 and 16. As seen from this example, single lines can be output only by specifying them twice; that is, as a range of one line. If the /S (set) switch is specified then the input source is not viewed as a single continuum of lines 1-n, but rather, as multiple, repeating groups of lines; i.e., 1-<no of sets>, 1-<no of sets>, 1-<no of sets> ... In such case, all specified ranges of lines are output from each group. To illustrate the LinesByPos filter, suppose you wanted to exclude unwanted fields from the comma-delimited text:

54667,Tiny Tim,05/05/1980,M
87896,John Doe,01/15/1960,M
98798,Lex Luther,05/26/1940,M

You might want, for example, to exclude the first and last fields of each line leaving only the person's name and birthdate. To do this, first you need to parse each line's fields onto separate lines. One way to accomplish this is by using the ReplStr filter to replace the commas with end-of-lines:

ReplStr ',' '\e'

Execution of this one-filter pipe gives us the following:

54667
Tiny Tim
05/05/1980
M
87896
John Doe
01/15/1960
M
98798
Lex Luther
05/26/1940
M

Note: The ReplStr filter will not work if the comma-delimited data includes quoted strings that can contain commas. In such a case the ParseCSV filter is recommended instead.  

Next, in order to exclude all fields except name and birthdate, the LinesByPos filter is added:

ReplStr ',' '\e'
LinesByPos 2 3 /s4

This gives us:

Tiny Tim
05/05/1980
John Doe
01/15/1960
Lex Luther
05/26/1940

Finally, we add three more filters:

ReplStr ',' '\e'
LinesByPos 2 3 /s4
AppendStr ','
JoinLines 2
StripChars 1

These added filters restore the commas, join the lines (in groups of 2) and then strip off the extraneous commas on the end of each line, giving us the output we desire:

Tiny Tim,05/05/1980
John Doe,01/15/1960
Lex Luther,05/26/1940

Outputting a range of lines from a list according to position can also be accomplished by use of the TopLines and BottomLines filters. See BottomLines for an example of this.  

See also BottomLines, TopLines


LowerCase           

syntax: LowerCase 

converts uppercase characters to lowercase                                                      

The LowerCase filter converts uppercase characters to lowercase.

See also UpperCase


MultValues          

syntax: MultValues [<char pos>...] /I<ins char pos> /W<width> /D<decimals> /S                                                            

multiplies two or more numbers in the input text                                                

The MultValues filter multiplies two or more numbers found in each input line and outputs the result of the multiplication per each line. Each parameter supplied is the character position of a number to be multiplied and in each case it must point at the left-most digit of the number to be multiplied or at the white space prior to it. Alternately, if no parameters are specified then each input line of text is expected to contain numeric values separated by whitespace, If the /I switch is specified, the result of each multiplication is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.

Given the four columns of numbers:

3      2      4     10
2      6      3.2   1.8
----+----1----+----2----+----3----+----4

the pipe,

MultValues 1 5 15 20 

will result in:

240.00
 69.12
----+----1----+----2----+----3----+----4

Adding the /I switch,

MultValues 1 5 15 20 /I30

causes the result of the multiplication to be inserted back into each line, in this case at character position 30:

3      2      4     10       240.00 
2      6      3.2   1.8       69.12 
----+----1----+----2----+----3----+----4


OutDuplLines        

syntax: OutDuplLines [<begin char pos> <end char pos>] /D<delimiter> /I                                                                    

outputs lines that are duplicated in the text                                                   

The OutDuplLines filter acts on sorted lists and outputs only those lines that are duplicated in the input text. If the optional range of character positions is specified then uniqueness is determined based on that range only. If a delimiter is specified using the /D switch, then uniqueness is based on the text at the beginning of each line up to the delimiter. If the /I switch is specified, case is ignored in determining uniqueness. 

Note: In order for the OutDuplLines filter to work, the input text must be sorted. If outputting duplicate lines based on a range of character positions, the input text must be sorted on that same range of character positions.   

Note: Either a range or a delimiter should be specified, but not both.

To illustrate, given the following text,

1   40   now
2   34   is
3   26   the
4   40   time
5   48   for
6   32   all
7   26   good
8   88   men
9   40   to
----+----1----+----2

suppose you wanted to obtain a listing of all lines that were duplicated based on the 2-digit numbers in the second column. The pipe,

SortLines /P5 
OutDuplLines 5 6 

would result in the desired output:
   
7   26   good
3   26   the
1   40   now
4   40   time
9   40   to
----+----1----+----2

If, however you just wanted to know which 2-digit numbers were duplicated, you would add an extra couple of filters:

SortLines /P5 
OutDuplLines 5 6 
DelDuplLines 5 6 
SubStr 5 2

This would result in a unique list as follows:

26
40

See also DelDuplLines, SortLines


OverlayChars        

syntax: OverlayChars <char pos> <string> [<char pos> <string>...]                                                                          

overlays each line with character strings at specified character positions                      

The OverlayChars filter overlays each line at the specified character position with a string. Multiple overlays can be performed at the same time. Given the text,

23.6 123 19.77
12.1 223 20.50
----+----1----+----2

the pipe,

OverlayChars 5 ',' 9 ','

gives:

23.6,123,19.77
12.1,223,20.50
----+----1----+----2

See also InsStr, AppendStr


PadLinesLeft        

syntax: PadLinesLeft <pad string> /W<pad width> /S<no of sets>                                                                             

pads each line on the left to the given character width with the given character string         

The PadLinesLeft filter pads each line on the left with the given character string to the width of the longest line. If the /W switch is specified then all lines are padded to that width instead. If the /S switch is specified then each line is padded to the width of the longest line in its set. 

Given the text,

the
quick brown
fox
jumped
over the lazy
dog and
the lazy
dog
didn't even bark

the pipe,

PadLinesLeft '*' 

outputs each line padded on the left with asterisks to the width of the longest line:

*************the
*****quick brown
*************fox
**********jumped
***over the lazy
*********dog and
********the lazy
*************dog
didn't even bark

Adding the /S switch gives us the pipe:

PadLinesLeft '*' /s2

Its execution outputs each individual line padded on the left with asterisks to the width of the longest line in its set:

*************the
quick brown
*************fox
*****jumped
***over the lazy
****dog and
********the lazy
********dog
didn't even bark

One reason for wanting to pad lines in this way is in preparation for outputting them as columns. Granted, that could be done without using the /S switch but using it allows the columns to be output will a minimum of space between them. In the case of the PadLinesLeft filter this is best illustrated using numbers. Given the following list of numbers:

3.33
23455.45
1.20
5345.39
5345345.50
223.11
465456.53
0.54
2352345345.67

the pipe,

PadLinesLeft ' ' /s3
AppendStr ' '
JoinLines 3

gives us three closely-spaced columns of text, each one neatly right-justified:

     3.33   23455.45          1.20 
  5345.39 5345345.50        223.11 
465456.53       0.54 2352345345.67 
----+----1----+----2----+----3----+----4----+----5
   
Note: The number of sets referenced in the PadLinesLeft filter and the number of lines referenced in the JoinLines filter must be the same for the columns to output properly. To increase the number of output columns simply increase the number of sets in the PadLinesLeft filter and the number of lines in the JoinLines filter.   

Note: The /S switch is ignored if a /W switch is specified.

See also PadLinesRight


PadLinesRight       

syntax: PadLinesRight <pad string> /W<pad width> /S<no of sets>                                                                             

pads each line on the right to the given character width with the given character string        

The PadLinesRight filter pads each line on the right with the given character string to the width of the longest line. If the /W switch is specified then all lines are padded to that width instead. If the /S switch is specified then each line is padded to the width of the longest line in its set. 

Given the text,

the
quick brown
fox
jumped
over the lazy
dog and
the lazy
dog
didn't even bark

the pipe,

PadLinesRight '*' 

outputs each line padded on the right with asterisks to the width of the longest line:

the*************
quick brown*****
fox*************
jumped**********
over the lazy***
dog and*********
the lazy********
dog*************
didn't even bark

Adding the /S switch gives us the pipe:

PadLinesRight '*' /s2

Its execution outputs each individual line padded on the right with asterisks to the width of the longest line in its set:

the*************
quick brown
fox*************
jumped*****
over the lazy***
dog and****
the lazy********
dog********
didn't even bark

One reason for wanting to pad lines in this way is in preparation for outputting them as columns. Granted, that could be done without using the /S switch but using it allows the columns to be output with a minimum of space between them. Starting with the same text as before, the pipe,

PadLinesRight ' ' /s3
AppendStr '|'
JoinLines 3

gives us three closely-spaced columns of text, each one neatly left-justified and separated by a "|" character:

the     |quick brown  |fox             |
jumped  |over the lazy|dog and         |
the lazy|dog          |didn't even bark|
----+----1----+----2----+----3----+----4----+----5
   
Note: The number of sets referenced in the PadLinesRight filter and the number of lines referenced in the JoinLines filter must be the same for the columns to output properly. To increase the number of output columns simply increase the number of sets in the PadLinesRight filter and the number of lines in the JoinLines filter.   

Note: The /S switch is ignored if a /W switch is specified.

See also PadLinesLeft


ParseCSV            

syntax: ParseCSV /Q<quote> /D<delimiter> /B                                                                                            

parses quoted, comma-delimited fields onto separate lines                                       

The ParseCSV filter parses comma-separated data values onto separate lines. Any surrounding quotes are left intact and by default, they are expected to be double-quotes; however, the character expected for quotes can be changed using the /Q switch. Likewise, by default the delimiter character expected to separate fields is a comma but it can be changed using the /D switch. If a quoted string contains embedded quotes then they must be in pairs. For example, """Tiny"" Tim Thompson". Alternatively, if the /B switch is specified, embedded quotes are expected to be represented with the backslash character (\) followed by a quote. For example, "\"Tiny\" Tim Thompson".

Note: ParseCSV expects that data values are either quoted or unquoted. Unquoted values are generally ordinal / numeric values like 56, 1.23 or true. Because whitespace is allowed both before and after delimiters, unquoted data values cannot contain embedded whitespace (actually, they can contain whitespace but it will be removed).

Suppose you wanted to translate the following quoted, comma-delimited data to fixed-width:

"54667","""Tiny"" Tim","05/05/1980","M",20456.45,"2347281749"
"98798","Luther, Lex","05/26/1940","M",9834.01,"4566281737"
"67491","Betty Boop","05/26/1932","F",34772.01,"1902630722"
----+----1----+----2----+----3----+----4----+----5----+----6----+----7

The first step in doing this is to parse all of the comma-separated fields onto separate lines. You could use the ReplStr filter to replace all commas (,) with carriage return / linefeeds, in-effect forcing all fields onto separate lines; however, any of the string fields could contain a comma (as for example, the name "Luther, Lex" in the second line) and therefore this isn't an ideal solution. A better approach is to use the ParseCSV filter instead.  

Sending the above data through the one-filter pipe,


ParseCSV

outputs each field onto a separate line:

"54667"
"""Tiny"" Tim"
"05/05/1980"
"M"
20456.45
"2347281749"
"98798"
"Luther, Lex"
"05/26/1940"
"M"
9834.01
"4566281737"
"67491"
"Betty Boop"
"05/26/1932"
"F"
34772.01
"1902630722"
----+----1----+----2

Adding 3 more filters to the pipe gives us:

ParseCSV
QuoteLines 1 6 /s6 /u
PadLinesRight ' ' /s6
JoinLines 6

The /U switch used by the QuoteLines filter is needed to unquote each line, (i.e. remove the outer quotes surrounding each line and then restore any embedded quotes). Finally, the parsed and unquoted fields are padded with blanks using PadLinesRight and then re-joined into fixed-width lines using JoinLines. The final output is:

54667"Tiny" Tim 05/05/1980M20456.452347281749
98798Luther, Lex05/26/1940M9834.01 4566281737
67491Betty Boop 05/26/1932F34772.011902630722
----+----1----+----2----+----3----+----4----+----5

For an example in which fixed-width data is translated to quoted, comma-delimited, see the QuoteLines filter. For an example that illustrates excluding fields from comma-delimited data (in which ParseCSV can be used) see the LinesByPos filter.


ParseWords          

syntax: ParseWords /D<delimiter>                                                                                                         

parses the text into individual words                                                           

The ParseWords filter parses each "word" of the input text onto a separate line. By default, a "word" is any text that is delimited by blanks. If you want other characters to be considered as delimiters, you must provide a delimiter string using the /D switch.

Given the text,

Hurry!... Time's a wastin!

The pipe,

ParseWords

will produce the following output:

Hurry!...
Time's
a
wastin!

With additional delimiters specified via the /D switch,

ParseWords /D' !.''' 

the output becomes:

Hurry
Time
s
a
wastin


QuoteLines          

syntax: QuoteLines <begin line> <end line> [<begin line> <end line>...] /B /D<delimiter> /O<option> /Q<quote> /S<no of sets> /U          

surrounds lines with quotes                                                                     

The QuoteLines filter is a special purpose filter used to translate fixed-width data to quoted, comma-delimited data. It surrounds those lines that fall within the specified range with quotes and replaces each embedded quote with a pair of quotes. If the /B switch is specified then embedded quotes are replaced by a backslash character (\) followed by a quote instead of two quotes. By default, quotes are expected to be double-quotes; however, the character expected for quotes can be changed using the /Q switch. Likewise, by default the delimiter character expected to separate fields is a comma but it can be changed using the /D switch. Multiple ranges can be specified but they must be in asending order. For example, 1 3 7 10 16 16 would result in the quoting of lines 1-3, 7-10 and 16. As seen from this example, single lines can be quoted only by specifying them twice; that is, as a range of one line.  If the /S (set) switch is specified then the input source is not viewed as a single continuum of lines 1-n, but rather, as multiple, repeating groups of lines; i.e., 1-<no of sets>, 1-<no of sets>, 1-<no of sets>... In such case, all specified ranges of lines are quoted within each group. The /O (option) switch determines how quoting is performed. It can be specified as one of three values:

0: 	Each line in range is quoted unconditionally (default).
1: 	Each line in range is quoted only if it contains embedded quotes or delimiters.
2: 	Each line in range is quoted only if it constitutes a non-numeric value.

Note: To be considered a numeric value, a line must only contain the characters 0-9.

The /U switch forces the QuoteLines filter to work in reverse. That is, it is used to unquote all lines that fall within the specified range(s). It first removes any outer quotes from each line and then restores embedded quotes. For an example that illustrates use of the /U switch, see the ParseCSV filter.

The following example illustrates use of the QuoteLines filter to translate fixed-width data to quoted, comma-delimited data using option 0. Given the following fixed-width data representing zip code, name, birthdate, sex, account balance and account number,

54667  "Tiny" Tim   05/05/1980  M   20456.45   2347281749
87896  John Doe     01/15/1960  M   234888.56  6482610982
98798  Luther, Lex  05/26/1940  M   9834.01    4566281737
67491  Betty Boop   05/26/1932  F   34772.01   1902630722
----+----1----+----2----+----3----+----4----+----5----+----6

the pipe,

SplitLines 8 21 33 37 48
TrimLinesRight
QuoteLines 1 4 6 6 /s6
AppendStr ','
JoinLines 6
StripChars 1

outputs:

"54667","""Tiny"" Tim","05/05/1980","M",20456.45,"2347281749"
"87896","John Doe","01/15/1960","M",234888.56,"6482610982"
"98798","Luther, Lex","05/26/1940","M",9834.01,"4566281737"
"67491","Betty Boop","05/26/1932","F",34772.01,"1902630722"
----+----1----+----2----+----3----+----4----+----5----+----6

Notice that every column that is in range is quoted unconditionally as per option 0. Here, we omitted the 5th column because we knew that it represented a numeric value. If we know that the target system doesn't require string fields to be quoted unless they contain embedded quotes or delimiters then, instead of the default (0), we could choose option 1 for the QuoteLines filter:

QuoteLines 1 4 6 6 /s6 /o1

This produces the following output in which only two cells are actually quoted:

54667,"""Tiny"" Tim",05/05/1980,M,20456.45,2347281749
87896,John Doe,01/15/1960,M,234888.56,6482610982
98798,"Luther, Lex",05/26/1940,M,9834.01,4566281737
67491,Betty Boop,05/26/1932,F,34772.01,1902630722
----+----1----+----2----+----3----+----4----+----5----+----6

Using option 1, we no longer need to specify particular columns to act on because now only those cells are quoted that have embedded quotes or delimiters; therefore, we could have the filter act on all 6 columns by specifying a single range that covers all of them:

QuoteLines 1 6 /s6 /o1

The resulting output would be identical to the previous output in this instance.

Finally, option 2 is useful when you want only non-numeric* columns to be quoted. Specifying the QuoteLines filter using option 2,

QuoteLines 1 6 /s6 /o2

gives us this output:

54667,"""Tiny"" Tim","05/05/1980","M",20456.45,2347281749
87896,"John Doe","01/15/1960","M",234888.56,6482610982
98798,"Luther, Lex","05/26/1940","M",9834.01,4566281737
67491,"Betty Boop","05/26/1932","F",34772.01,1902630722
----+----1----+----2----+----3----+----4----+----5----+----6

Now, those cells in each of the 6 columns that contain non-numeric values are quoted; however, the zip code and account number fields are not quoted because they only contain numeric characters. In this case, you could choose to manually specify each and every column to be quoted (using option 0) or you could use option 2 as shown above and simply add another QuoteLines filter (option 0) to handle quoting those columns that were not automatically handled by the first QuoteLines call. The entire pipe would be as follows:

SplitLines 8 21 33 37 48
TrimLinesRight
QuoteLines 1 6 /s6 /o2
QuoteLines 1 1 6 6 /s6 
AppendStr ','
JoinLines 6
StripChars 1

Its execution gives us the desired output:

"54667","""Tiny"" Tim","05/05/1980","M",20456.45,"2347281749"
"87896","John Doe","01/15/1960","M",234888.56,"6482610982"
"98798","Luther, Lex","05/26/1940","M",9834.01,"4566281737"
"67491","Betty Boop","05/26/1932","F",34772.01,"1902630722"
----+----1----+----2----+----3----+----4----+----5----+----6

Since the QuoteLines filter also works in-reverse, that is, it can unquote lines, you could use it to unquote any exceptional columns after having first quoted all columns using option 0.

For an example in which quoted, comma-delimited data is translated to fixed-width, see the ParseCSV filter.


ReorderColumns              

syntax: ReorderColumns <char pos> <char pos> [<char pos> <char pos>...] /C /P<char pos>                                                 

re-arranges the column order of each line                                            

The ReorderColumns filter re-arranges the column order of each line, allowing columns of data to be moved about, deleted or duplicated. Multiple character position pairs--each indicating a column of text to include in the output--can be specified in any order. The result is an aggregate of all such columns of text. If the /C switch is given then the second number in each pair is interpreted as a character count rather than an ending character position. This can be helpful if you know beforehand how wide each column is. If the /P switch is specified then the resulting aggregate is inserted back into each line at the given character position. This feature provides an alternative means of re-arranging the column order of the text.

Given the following text:

06/02/2002  02:39p  <dir>  Documents and Settings  Archived
10/28/2002  10:16a  <dir>  Outlook Mail Messages   Archived
05/12/2003  05:52p  <dir>  Program Files           Archived
04/14/2003  08:36a  <dir>  Trash                   Archived
04/01/2003  01:55p  <dir>  WINNT                   Archived
----+----1----+----2----+----3----+----4----+----5----+----6

Suppose you were only interested in viewing the date, time and description. The following pipe,

ReorderColumns 28 50 1 11 13 18

... will output just those fields:

Documents and Settings 06/02/2002 02:39p
Outlook Mail Messages  10/28/2002 10:16a
Program Files          05/12/2003 05:52p
Trash                  04/14/2003 08:36a
WINNT                  04/01/2003 01:55p
----+----1----+----2----+----3----+----4----+----5----+----6


ReplStr             

syntax: ReplStr <find string> <replace string> [<find string> <replace string>...] /B<char pos> /D<delimiter> /E<char pos> /I /P<place holder> /R  

replaces character strings found in the text                                                    

The ReplStr filter replaces each occurrence of <find string> found within each line with <replace string>. Multiple string replacements can be performed per call. If the /I switch is specified the find string is searched without regard to its case. If the /R switch is specified the find string is treated as a regular expression pattern. 

In addition to performing text replacements in which both the find and replace strings are specified as arguments, the ReplStr filter can also perform text replacements on an input line using a replace string that originates from the input line itself. If a /B switch is given, text will be extracted from the input line at the character position specified. This extracted text's ending position in the input line can be specified using the /E switch. As an alternative, you can omit the /E switch and by default, the text in the input line must be terminated (delimited) by a blank character. This delimiter character can be changed by specifying a /D switch.  

Note: The <delimiter> is a single character and not a string; therefore, only the first character of a specified delimiter will be used.

As text is extracted from the input line itself and used as a replace string when a /B switch is specified, you might wonder what use is the replace string argument in this case? The answer is that it acts as a template to describe how the extracted text is used during the text replacement. For clarification of the replace string argument used as a template, see the last example below.

As a first example to illustrate the basic functionality of the ReplStr filter, given the following text,

Pyper rocks
----+----1----+----2

... the following pipe,

ReplStr 'rocks' 'ROCKS!' 

... produces:

Pyper ROCKS!
----+----1----+----2

Because it's possible to replace a character string with one that contains an end-of-line, (\e) you can insert lines into the text output stream using the ReplStr filter. For example, given the following text,

the,quick,brown,fox
----+----1----+----2

... the pipe,

ReplStr ',' '\e'

... outputs:

the
quick
brown
fox
----+----1----+----2

Although, lines can be inserted into the text stream by inserting end-of-lines it's not possible to replace end-of-lines since they cannot actually be found in an input line of text. Fortunately, there's a way around this by using the JoinLines filter. This technique can be used to replace not only the end-of-lines, but also strings that are adjacent to them. 

For example, the following pipe uppercases any occurence of "the" that is located at the end of a line:

AppendStr '<eol>'
JoinLines
ReplStr 'the<eol>' 'THE<eol>' '<eol>' '\e'

Given the text,

you can use the replstr filter
to replace end-of-lines with the
help of the joinlines filter
----+----1----+----2----+----3

... the above pipe outputs the following:

you can use the replstr filter
to replace end-of-lines with THE
help of the joinlines filter
----+----1----+----2----+----3

As you can see, only one "the" is uppercased but the other two are left unchanged as they are not at the end of a line. 

Note: This is not how you would typically approach the problem of replacing strings at the end of lines. I show this only to illustrate that end-of-lines themselves can be referenced in a find string and thus be replaced or deleted (in fact, this is commonly done in Pyper). In practice, the above would be done using a regular expression:

ReplStr 'the$' 'THE' /r

As noted above, the ReplStr filter can perform text replacements using a replace string that originates from the input line itself. This feature is exploited in the "Create an Index" demo that is accessible via Pyper's About menu. Of relevance to this discussion are the following lines, including comments, from the middle of the pipe (Create An Index.pip):

; Distribute the page number across each line
; to every word on that line:

ReplStr ' ' ':% ' /b1 /d':'

; Remove the page number and ":" at the head of each line:

DelChars 1 5

Format-wise, the text that is input to the ReplStr filter at this point in the pipe looks something like this (the number of words is reduced here for illustration purposes):

0001:Joseph Priestley March Old Style February 
0002:Early life and education Priestley was born 
0003:Priestley later wrote that the book that 
0004:Warrington Academy In Priestley moved to 
----+----1----+----2----+----3----+----4----+----5

Note: Each of these lines ends with a space.

When run through the above two filters, the 4-digt page number at the head of each line is "distributed" across the line to each word and then removed from the head of the line:

Joseph:0001 Priestley:0001 March:0001 Old:0001 Style:0001 February:0001 
Early:0002 life:0002 and:0002 education:0002 Priestley:0002 was:0002 born:0002 
Priestley:0003 later:0003 wrote:0003 that:0003 the:0003 book:0003 that:0003 
Warrington:0004 Academy:0004 In:0004 Priestley:0004 moved:0004 to:0004 
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

In the actual demo, (Create An Index.pip) this resulting text is then further processed to form the word index, (which is beyond the scope of this example). 

As noted earlier, when the ReplStr filter is used with the /B switch, the replace string argument is treated as a template. Here, in this example, the template is specified as ":% '. The "%" is a placeholder that will be replaced by the text that gets extracted from the input line. The result of this replacement is then used to replace any blanks that are found in the input line. On the first line for example, the text "0001" replaces the "%" in the template resulting in ":0001 ". This resulting string is then used to replace all blanks in the first line of the input text. The remaining input lines are handled accordingly.

Note: The placeholder can be changed using the /P switch.


ReverseChars        

syntax: ReverseChars [<begin char pos> <end char pos>]                                                                                     

reverses the characters in each line of the input text                                                            

The ReverseChars filter reverses the characters in each line of the input text. If a range of character positions is specified, then just those characters will be reversed. The ReverseChars filter is mostly useful as a pre-filter for other filters. For example, given the following text,

brake pads 12.50
brake drums 32.90
spark plug wires 06.75
radiator hose 05.49
----+----1----+----2----+----3----+----4

suppose you wanted to insert a dollar sign, "$" ahead of the cost for each item. The InsStr filter alone can't help here because the character position of the cost varies from line to line. However, if the characters on each line were reversed, the dollar sign could then be inserted at column 6 for each line. The following pipe does exactly this and then it reverses the resulting text a second time in order to return it back to it's initial state:

ReverseChars 
InsStr 6 '$' 
ReverseChars 

The result of its execution on the above text is as follows:

brake pads $12.50
brake drums $32.90
spark plug wires $06.75
radiator hose $05.49
----+----1----+----2----+----3----+----4

Note: The particular problem presented here is merely for demonstration. Were this problem actually encountered, you'd likely use the ReplStr filter and a regular expression to solve it.


RightChars          

syntax: RightChars <no of chars>                                                                                                         

returns the given number of characters from the end of each line of text                        

The RightChars filter outputs the specified right-most characters from each input line of text. 

Given the text,

Table, 123.45
Chair, 061.22
----+----1----+----2

the pipe,

RightChars 6

gives:

123.45
061.22
----+----1----+----2

See also LeftChars


RotCharsLeft        

syntax: RotCharsLeft <no of chars>                                                                                                         

rotates characters left given no of places                                                      

The RotCharsLeft filter rotates the characters in each line the specified number of characters to the left. 

See also RotCharsRight and RotCharsToStr


RotCharsRight       

syntax: RotCharsRight <no of chars>                                                                                                         

rotates characters right given no of places                                                     

The RotCharsRight filter rotates the characters in each line the specified number of characters to the right. 

See also RotCharsLeft and RotCharsToStr


RotCharsToStr       

syntax: RotCharsToStr <string> /I /N<count> /R                                                                                              

rotates each line until given string is at its beginning                                        

The RotCharsToStr filter rotates the characters in each line left until the specified string is located at the beginning of the line. If the desired string is already located at the beginning of a line no rotation takes place. If a count is specified using the /N switch, that number of rotate-to-string operations is carried out. This enables you to target any ocurrence of a string that exists multiple times in a line being rotated. If the /I switch is specified the string is matched regardless of case. If the /R switch is specified the string is treated as a regular expression pattern.

As an example, suppose you wanted to insert a "$" ahead of the item cost in each line:

64339; Table, w/ glass top; 123.45; Furniture Dept.
94732; Chair, high back w/ cushion; 61.22; Furniture Dept.
----+----1----+----2----+----3----+----4----+----5----+----6

AppendStr '<eol>'
RotCharsToStr ';' /n2
InsStr 3 '$'
RotCharsToStr '<eol>'
DelChars 1 5

Its execution result in the following:

64339; Table, w/ glass top; $123.45; Furniture Dept.
94732; Chair, high back w/ cushion; $61.22; Furniture Dept.
----+----1----+----2----+----3----+----4----+----5----+----6

Perhaps a better way to do this would be using regular expressions but this serves to illustrate a typical use for the RotCharsToStr filter.

One use of the RotCharsToStr filter that isn't immediately obvious is to have it rotate not just each line individually but the entire input text. For an in-depth example see the demo, "Edit HTML Files". To illustrate this with a more concise example, suppose you had the following lines of text:

The RotCharsToStr filter
can be used to rotate
the lines in the text.
----+----1----+----2----+----3

Suppose you wanted to rotate them upward so that the second line ended up at the top. The following pipe makes use of the RotCharsToStr filter to accomplish this:

AppendStr '<eol>'
JoinLines
RotCharsToStr '<eol>' 
RotCharsLeft 5
StripChars 5
ReplStr '<eol>' '\e'

Its execution results in the following:

can be used to rotate
the lines in the text.
The RotCharsToStr filter
----+----1----+----2----+----3

See also RotCharsLeft and RotCharsRight


SetDebugOn          

syntax: SetDebugOn 

configures pipe debugging on                                                                    

???


SetDebugOff         

syntax: SetDebugOff 

configures pipe debugging off                                                                   

???


ShiftChars          

syntax: ShiftChars <char pos> <string> [<char pos> <string>...] /I /R                                                                    

shifts text into specified character positions                                                  

The ShiftChars filter shifts text into specified character positions, (deleting any text that is shifted over). It will shift the text either to the left or to the right as necessary. The first parameter is the character position to shift the text to and the second parameter specifies the string to be shifted. Any number of position/string pairs can be specified but the character positions must be in ascending order. If the /I switch is specified the case of the strings is ignored. If the /R switch is specified the strings are treated as a regular expression patterns.

The ShiftChars filter is useful for forcing text into a specific column position so that subsequent filters can operate based on that assumption. For example, given the following data delimited by commas,

John L. Doe,42,Miami,FL
Frank N. Stein,20,Los Angeles,CA
Norma Lee,16,Austin,TX
----+----1----+----2----+----3----+----4

... the following pipe, 

ShiftChars 15 ',' 18 ',' 30 ','
DelChars 15 1 18 1 30 1

... will output the data fixed-width:

John L. Doe   42Miami      FL
Frank N. Stein20Los AngelesCA
Norma Lee     16Austin     TX
----+----1----+----2----+----3----+----4

Here, the same string, (a comma) is specified repeatedly but each specified string could be different. 

Note: The above is not a particularly good way to transform CSV data to fixed-width. This is partly because you don't necessarily know beforehand what column to shift the commas to (that will accomodate the widest field for that column). The preferred approach would be to use the ParseCSV filter along with the PadLinesRight and JoineLines filters. See ParseCSV for an example.

Another use for ShiftChars is to simply delete text at some given character position up to a given string (a function that the DelCharsToStr also performs). For example, suppose you wanted only the third and last fields of the following lines of data:

2010/08/15, 12:15:48.030, 983900002, A, 34.45.22.65, N47, 0003535, Driver Failure
2010/08/15, 12:16:01.473, 0872303, A, 34.45.22.65, N47, 0003535, Bad Drive at 45453:883
2010/08/15, 12:16:02.229, 740900002, A, 34.45.22.65, N226, 0003535, System Configured
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9

This can be achieved using ShiftChars by making use of the comma characters. The following pipe,

ShiftChars 1 ',' 1 ',' 13 ',' 13 ',' 13 ',' 13 ',' 13 ',' 
DelChars 1 2

... delivers the goods:

983900002 , Driver Failure
0872303   , Bad Drive at 45453:883
740900002 , System Configured
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9

Here, the first two commas are shifted, one after the other, into character position 1. This effectively wipes out the first two fields of data. Then, the next five commas are shifted into position 13, effectively removing fields 4 through 7. 

Note: When a string is referenced multiple times by the ShiftChars filter, each reference refers to the next "unshifted" occurrence of that string found in the input text. Once an occurrence of that string in the input text has been referenced it can no longer be referenced again by the same ShiftChars filter.

See also DelCharsToStr


SortLines           

syntax: SortLines /P<char pos> /R                                                                                                   

sorts the text                                                                                  

The SortLines filter outputs the text sorted. The /P switch can be used to specify which character position to sort the text on. By default, the text is sorted on character position 1 (that is, the sort is performed on the entire line of text). The /R switch causes the input text to be sorted in reverse order.  

Given the text,

the
quick brown
fox
jumped
over the lazy
dog and
the lazy
dog
didn't even bark
----+----1----+----2

...the following pipe parses it onto separate lines, inserts a line number ahead of each word and then sorts the text based on the words, not the line numbers:

ParseWords
InsStr 1 ' '
InsLineNo /w2 /z
SortLines /p4

Its execution results in the following:

10 and
16 bark
03 brown
14 didn't
09 dog
13 dog
15 even
04 fox
05 jumped
12 lazy
08 lazy
06 over
02 quick
11 the
01 the
07 the


SpliceFile          

syntax: SpliceFile <file name> /D<delimiter> /M

combines text from a text file to the input text                                                

The SpliceFile filter extends each line of the input text by appending to it its corresponding line from the splice file. In other words, the two text sources are "spliced" together. If either text source has more lines of text than the other, the extra lines are simply appended to the output and therefore, the input text and the splice file should contain the same number of lines of text. If a delimiter string is specified using the /D switch, it will be appended to each line of the input text ahead of the spliced text. If the /M (merge) switch is specified the text from the splice file is added to the end of the input text rather than spliced line-by-line. Note that the <file name> parameter must be a single-quoted string as it can contain blanks.

Given the following input text,

test.txt
rev.txt
list1.txt

... and the following text in LIST2.TXT,

05-26-99  5:19p
05-26-99  5:22p
05-26-99  5:30p

the pipe,

PadLinesRight ' '
AppendStr ' '
SpliceFile 'c:\list2.txt' 

will output the following:

test.txt  05-26-99  5:19p
rev.txt   05-26-99  5:22p
list1.txt 05-26-99  5:30p
----+----1----+----2----+----3----+----4


SplitLines          

syntax: SplitLines <char pos> [<char pos>...]                                                                                            

splits each line at the given character position(s)                                             

The SplitLines filter splits each line at the given character position(s). Multiple character positions can be specified where splitting is to occur but they must be in ascending order.

Suppose for example that you wanted to reform the following list of items so that they formed four columns instead of three:  

01 ONE,      02 TWO,      03 THREE,
04 FOUR,     05 FIVE,     06 SIX,
07 SEVEN,    08 EIGHT,    09 NINE,
10 TEN,      11 ELEVEN,   12 TWELVE,
13 THIRTEEN, 14 FOURTEEN, 15 FIFTEEN,
----+----1----+----2----+----3----+----4

To do this, you would first need to get each number and its associated comment onto a separate line by itself. One way to do this is using the SplitLines filter:

SplitLines 14 27 

Executing this pipe results in a single "column" of data:

01 ONE,      
02 TWO,      
03 THREE,
04 FOUR,     
05 FIVE,     
06 SIX,
07 SEVEN,    
08 EIGHT,    
...
----+----1----+----2

Adding PadLinesRight and JoinLines filters, we now have this:

SplitLines 14 27 
PadLinesRight ' ' /w15
JoinLines 4 

Its execution results in the desired four columns of data:

01 ONE,        02 TWO,        03 THREE,      04 FOUR,       
05 FIVE,       06 SIX,        07 SEVEN,      08 EIGHT,      
09 NINE,       10 TEN,        11 ELEVEN,     12 TWELVE,     
13 THIRTEEN,   14 FOURTEEN,   15 FIFTEEN,    
----+----1----+----2----+----3----+----4----+----5----+----6

Note: Other alternatives to using SplitLines may include ParseWords, InsStr, ReplStr and ParseCSV.


StripChars          

syntax: StripChars <no of chars>                                                                                                         

deletes a given number of characters from the end of each line                         

The StripChars filter deletes a given number of characters from the end of each line. For an example of its use, see the JoinLines filter.

See also DelChars


SubValues           

syntax: SubValues <char pos> <char pos> /I<ins char pos> /W<width> /D<decimals> /S                                                      

subtracts two numbers found on each line of text                                                

The SubValues filter subtracts two numbers found in each input line and outputs the result of the subtraction per each line. The two required parameters specify at what character positions the numbers involved in the subtraction are located and in each case must point at the leftmost digit of the number or at the white space prior to it. If the /I switch is specified, the result of the subtraction is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.

Given input text containing the two columns of numbers:

14       8
10       2.75
12.5     5.5
----+----1----+----2----+----3

the pipe,

SubValues 1 10 

outputs the result of each subtraction:

  6.00
  7.25
  7.00
----+----1----+----2----+----3

Adding the /I switch,

SubValues 1 10 /i20

causes the result of the subtraction to be inserted back into each line, in this case at character position 20:

14       8           6.00 
10       2.75        7.25 
12.5     5.5         7.00 
----+----1----+----2----+----3


TopLines            

syntax: TopLines <no of lines>                                                                                                         

outputs the given number of lines from the beginning of the input text                          

The TopLines filter outputs the given number of lines from the top of the input text. It can be used in conjunction with the BottomLines filter to return a range of lines from the middle of the input text. See the BottomLines filter for an example of how this is done. A range of lines can also be output using LinesByPos.

See also BottomLines, LinesByPos


TotalColumns        

syntax: TotalColumns <char pos> [<char pos>...] /W<width> /D<decimals> /A /S                                                               

totals columns of numeric values                                                                

For each character position specified, the TotalColumns filter totals the numeric values found on all input lines at that character position. A specified character position does not have to point directly at a value's first digit, but can point to the white space ahead of the value as well. The output from the TotalColumns filter is a single line of text that contains the totals of all columns specified. The totals are written to this output line at the character positions specified. The /W switch determines the width of each numeric total and the /D switch determines the number of decimal places displayed after the decimal point. If the /A switch is specified the line of totals is output preceded by the input text lines themselves containing the values being totalled. The line of totals is thus appended to the end of the input text. If the /S switch is specified the totals will be formatted in scientific notation.

Given the following input text:

john     20.00      12.24
fred     52.81       6.42
lisa      8.28      19.06
thomas   20.62     103.57
tom      36.87      72.80
----+----1----+----2----+----3----+----4

the pipe,

TotalColumns 9 20

outputs:

        138.58     214.09 
----+----1----+----2----+----3----+----4

If the decimal points of all the values in a column are lined-up as they are in this example, you generally want the resulting total's decimal point to line-up as well. The location of a column's total depends on both its starting character position specified and on the setting of the numeric width, (which can be overridden by using the /W switch). In this example the width is assumed to be the standard default of 6 therefore to have the resulting totals (their decimal points) line up properly with their respective columns, the first total's character position must be specified here as 9 instead of 10. In general, a total's starting character position desired is determined according to the formula:

<Total's Starting Char Pos> = <Column's Right-most Char Pos> - <Numeric Width> + 1
 
To create reports that total both horizontally and vertically, you can use the TotalColumns filter in conjunction with the AddValues filter. Here, we use the /A (append) switch with the TotalColumns filter:

AddValues 10 20 /i30
TotalColumns 9 20 30 /a

The result is as follows:

john     20.00      12.24     32.24 
fred     52.81       6.42     59.23 
lisa      8.28      19.06     27.34 
thomas   20.62     103.57    124.19 
tom      36.87      72.80    109.67 
        138.58     214.09    352.67 
----+----1----+----2----+----3----+----4


TrimLines           

syntax: TrimLines 

removes leading and trailing white space from each line of text                                 

The TrimLines filter simply combines both the TrimLinesLeft and TrimLinesRight filters into one. It removes both leading and trailing white space characters from each line of text.

See also TrimLinesLeft, TrimLinesRight.


TrimLinesLeft       

syntax: TrimLinesLeft 

removes leading white space from each line of text                                              

The TrimLinesLeft filter removes all leading blanks and tabs from the front of each line.

See also TrimLinesRight, TrimLines.


TrimLinesRight      

syntax: TrimLinesRight 

removes trailing white space from each line of text                                             

The TrimLinesRight filter removes all trailing blanks and tabs from the end of each line.

See also TrimLinesLeft, TrimLines.


UpperCase           

syntax: UpperCase 

converts lowercase characters to uppercase                                                      

The UpperCase filter converts lowercase characters to uppercase.

See also LowerCase


WrapText            

syntax: WrapText <char pos> /B<break chars> /J<%jaggedness>                                                                          

wraps text at given character position                                                          

The WrapText filter wraps the text at the given character position. By default, lines are broken at spaces only. Use the /B switch to provide a string containing additional break characters. For example, the string "-" would cause hyphens to be considered as break characters in addition to spaces. 

By default, break characters will be used that are within 25% of the end of a line (thus allowing lines to be 25% jagged). You can change this by specifying a different percentage value using the /J switch.

To illustrate the WrapText filter, suppose you had the following text,

If you allow 100% jaggedness, then the algothithm will favor breaking the
line even at a blank (or break char.) that it finds located near the
text's left margin, thus possibly resulting in "loose" lines that contain
just a word or two.  If set to 0%, no blank or break character found will
be used as a break point and instead, the line will simply be broken at
the margin (hence 0% jaggedness). 
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

... and you wanted it to be wrapped at character position 30. This can be accomplished using the following pipe:

TrimLines
AppendStr ' '
JoinLines
WrapText 30 

Since the input text is already on multiple lines, the first three filters are needed to transform it into a single line. Then, the WrapText filter, wraps the text as desired:

If you allow 100% jaggedness,
then the algothithm will
favor breaking the line even
at a blank (or break char.)
that it finds located near
the text's left margin, thus
possibly resulting in "loose"
lines that contain just a
word or two.  If set to 0%,
no blank or break character
found will be used as a break
point and instead, the line
will simply be broken at the
margin (hence 0% jaggedness).
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8


