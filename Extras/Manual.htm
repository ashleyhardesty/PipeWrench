<h2>Pyper's Core Text Filters</h2>

<p>Following are the core text filters that are included in Pyper:</p>

<p><font face="Courier" size="1">&nbsp;&nbsp;&nbsp;<a href = #AddValues>AddValues</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #AppendStr>AppendStr</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #BaseToDec>BaseToDec</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #BottomLines>BottomLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #Call>Call</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #CenterText>CenterText</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #ColumnOrder>ColumnOrder</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #CountChars>CountChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #CountLines>CountLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #CullLines>CullLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;<a href = #DecToBase>DecToBase</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #DelBlankLines>DelBlankLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #DelChars>DelChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #DelCharsToStr>DelCharsToStr</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #DelDuplLines>DelDuplLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #DelExtraBlankLines>DelExtraBlankLines</a>&nbsp;&nbsp;<a href = #DelExtraBlanks>DelExtraBlanks</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #DivValues>DivValues</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #EndIsolate>EndIsolate</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #ExclLines>ExclLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;<a href = #ExtractLines>ExtractLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #FoldLines>FoldLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #GroupLines>GroupLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #InclLines>InclLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #InsLineNo>InsLineNo</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;<a href = #InsStr>InsStr</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #IsolateLines>IsolateLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #JoinLines>JoinLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #JustCharsLeft>JustCharsLeft</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #JustCharsRight>JustCharsRight</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #LeftChars>LeftChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #LinesByPos>LinesByPos</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #LowerCase>LowerCase</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #MultValues>MultValues</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #OutDuplLines>OutDuplLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #OverlayChars>OverlayChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #PadLinesLeft>PadLinesLeft</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #PadLinesRight>PadLinesRight</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #ParseCSV>ParseCSV</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #ParseWords>ParseWords</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #QuoteLines>QuoteLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #ReorderColumns>ReorderColumns</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #ReplStr>ReplStr</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #ReverseChars>ReverseChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #RightChars>RightChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #RotCharsLeft>RotCharsLeft</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #RotCharsRight>RotCharsRight</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #RotCharsToStr>RotCharsToStr</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #SetDebugOff>SetDebugOff</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #SetDebugOn>SetDebugOn</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #ShiftChars>ShiftChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #SortLines>SortLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #SpliceFile>SpliceFile</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #SplitLines>SplitLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #StripChars>StripChars</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;<a href = #SubValues>SubValues</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #TopLines>TopLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #TotalColumns>TotalColumns</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #TrimLines>TrimLines</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #TrimLinesLeft>TrimLinesLeft</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
&nbsp;&nbsp;&nbsp;<a href = #TrimLinesRight>TrimLinesRight</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href = #UpperCase>UpperCase</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href = #WrapText>WrapText</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</font></p>

<a name="AddValues"><h3>AddValues</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">AddValues [&lt;char pos&gt;...] /I&lt;ins pos&gt; /W&lt;width&gt; /D&lt;decimals&gt; /S</font><br>
<font size="1">summary: </font><font size="1" color="gray">adds two or more numbers found in each input line</font></p>

<p>The AddValues filter adds two or more numbers found in each input line and outputs the result of the addition per each line. Each parameter supplied is the character position of a number to be added and in each case it must point at the left-most digit of the number to be added or at the white space prior to it. Alternately, if no parameters are specified then each input line of text is expected to contain numeric values separated by whitespace. If the /I switch is specified, the result of each addition is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.</p>

<p>Given input text containing the four columns of numbers,</p>

<p><font size="1" face="Courier" color="gray"> 2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5<br>
 3.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">AddValues 1 11 21 31</font></p>

<p>outputs the result of each addition:</p>

<p><font size="1" face="Courier" color="gray"> 18.50<br>
 30.00<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>Adding the /I switch,</p>

<p><font size="1" face="Courier" color="gray">AddValues 1 11 21 31 /i41</font></p>

<p>causes the result of the addition to be inserted back into each line, in this case at character position 41:</p>

<p><font size="1" face="Courier" color="gray"> 2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18.50<br>
 3.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30.00<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>See also SubValues, MultValues, DivValues</p>

<a name="AppendStr"><h3>AppendStr</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">AppendStr &lt;string&gt; /P</font><br>
<font size="1">summary: </font><font size="1" color="gray">concatenates the supplied string to the end of each line of the input text</font></p>

<p>The AppendStr filter concatenates the supplied string to the end of each line of the input text and then outputs the resulting lines. If the /P switch is specified then the string is instead pre-pended to each line of the input text.</p>

<p>Given the following list of files (minus file extensions),</p>

<p><font size="1" face="Courier" color="gray">convert<br>
this<br>
that<br>
theother</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">AppendStr '.bat' /b</font></p>

<p>will output:</p>

<p><font size="1" face="Courier" color="gray">convert.bat<br>
this.bat<br>
that.bat<br>
theother.bat</font></p>

<p>This next example illustrates how to insert a line of text using the AppendStr filter in combination with text isolation. Given the following text,</p>

<p><font size="1" face="Courier" color="gray">this is line 1<br>
this is line 3<br>
this is line 4</font></p>

<p><font size="1" face="Courier" color="gray">IsolateLines 'line 1'<br>
&nbsp;&nbsp; AppendStr '\ethis is line 2'<br>
EndIsolate</font></p>

<p>will output:</p>

<p><font size="1" face="Courier" color="gray">this is line 1<br>
this is line 2<br>
this is line 3<br>
this is line 4</font></p>

<p>See also InsStr</p>

<a name="BaseToDec"><h3>BaseToDec</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">BaseToDec &lt;radix&gt; /I&lt;ins char pos&gt; /S&lt;scan char pos&gt; /W&lt;width&gt; /Z</font><br>
<font size="1">summary: </font><font size="1" color="gray">converts numbers of the given base found in the input text to decimal</font></p>

<p>The BaseToDec filter converts whole numbers of the given base, (2 - 62) found in the input text to decimal, (base 10) and then outputs the resulting values. The only required parameter is the radix of the numeric values found in the input text. If an insert character position is specified using the /I switch the resulting decimal value will be inserted into the output text at the specified character position rather than being output alone. The /S switch can be used to specify the character position where scanning for the input values begins. If the /S switch is omitted, scanning begins at character position 1. The /W switch determines the width of the numeric result. The default is 6. The /Z switch causes the value(s) to be displayed with leading zeros.</p>

<p>The characters read from standard input must follow the numerical sequence (dependent on radix):</p>

<p>"0" - "9", "A" - "Z", "a" - "z"</p>

<p>Because this sequence contains both upper and lower case characters, case is obviously significant when considering numbers to be converted.&nbsp;&nbsp;As such, even if they were of the same base, the values "f2ac" and "F2AC" would not be equivalent!</p>

<p>To illustrate the BaseToDec filter, the binary value,</p>

<p><font size="1" face="Courier" color="gray">10011</font></p>

<p>run through the pipe,</p>

<p><font size="1" face="Courier" color="gray">BaseToDec 2</font></p>

<p>will output:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;&nbsp;&nbsp;19<br>
----+----1----+----2</font></p>

<p>The BaseToDec filter can be used in conjunction with the DecToBase filter to perform base conversions from one base to another assuming that they are both in the range, (2 - 62).&nbsp;&nbsp;See the DecToBase filter for an example of how this is done.</p>

<p>See also DecToBase</p>

<a name="BottomLines"><h3>BottomLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">BottomLines &lt;no of lines&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">outputs the given number of lines from the end of the text</font></p>

<p>The BottomLines filter outputs the given number of lines from the bottom of the input text. It can be used in conjunction with the TopLines filter to return a range of lines from the middle of the input text. For example, given the following input text,</p>

<p><font size="1" face="Courier" color="gray">this is line 1<br>
this is line 2<br>
this is line 3<br>
this is line 4</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">TopLines 3<br>
BottomLines 2</font></p>

<p>will output:</p>

<p><font size="1" face="Courier" color="gray">this is line 2<br>
this is line 3</font></p>

<p>For another way of returning a range of lines, see the LinesByPos filter.</p>

<p>See also TopLines, LinesByPos</p>

<a name="Call"><h3>Call</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">Call &lt;pipe file name&gt; [&lt;arg&gt;...]</font><br>
<font size="1">summary: </font><font size="1" color="gray">calls a pipe from the currently executing pipe</font></p>

<p>The Call command is used to invoke or call another pipe from the currently executing pipe. It takes as its first argument a single-quoted string that represents the called pipe's filename:</p>

<p>Call 'c:\pipes\mypipe.pip' ...</p>

<p>Just like with filters, pipes can accept arguments and switches. In a Call command, any such arguments or switches that follow the called pipe's filename are passed to the called pipe. The arguments and switches that are expected by a called pipe is determined by its template. This template is recorded in the comment block at the top of the pipe (its "header"). To illustrate the calling of a pipe, we start with a pipe that's been saved to disk as "Envelop.pip":</p>

<p><font size="1" face="Courier" color="gray">; Name: Envelop.pip<br>
; Template: s s<br>
;<br>
; This pipe envelops each line<br>
; inside the given two strings.<br>
;<br>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</font></p>

<p><font size="1" face="Courier" color="gray">InsStr 1 '[1]'<br>
AppendStr '[2]'</font></p>

<p>As you can see, the pipe's template is "s s". This tells Pyper that the pipe requires two string arguments. It could therefore be called from another pipe as shown here:</p>

<p><font size="1" face="Courier" color="gray">; Name: MainPipe.pip<br>
;<br>
; This pipe parses the given text onto<br>
; separate lines, envelops each line<br>
; inside two strings and then uppercases<br>
; the text.<br>
;<br>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</font></p>

<p><font size="1" face="Courier" color="gray">ParseWords<br>
Call 'Envelop.pip' '&lt;&lt;&lt;' '&gt;&gt;&gt;'<br>
UpperCase</font></p>

<p>Note: If the called pipe is referenced without a path, (i.e. "mypipe.pip") it must exist in the same folder as the calling pipe.</p>

<a name="CenterText"><h3>CenterText</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">CenterText &lt;field width&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">centers the input text in a field of the given character width</font></p>

<p>The CenterText filter centers the input text in a field of the given character width by padding on the left with the appropriate number of blank characters.</p>

<p>Given the input text,</p>

<p><font size="1" face="Courier" color="gray">This<br>
Is<br>
Centered</font></p>

<p>The pipe,</p>

<p><font size="1" face="Courier" color="gray">CenterText 50</font></p>

<p>results in:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Centered<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<a name="ColumnOrder"><h3>ColumnOrder</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ColumnOrder &lt;no of rows&gt; &lt;no of columns&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">a pre-filter to the JoinLines filter which allows columns to be ordered down instead of across</font></p>

<p>The ColumnOrder filter is used as a pre-filter to the JoinLines filter so that the text stream can be reformed into columns that are ordered top to bottom instead of being ordered left to right as would normally be output from the JoinLines filter, given a sorted list of items. The first parameter required is the number of rows that you wish to limit the table to. The second is the number of columns.</p>

<p>To illustrate, suppose you wanted to format a list of unordered names into 3 columns, ordered. Given the list of unordered names,</p>

<p><font size="1" face="Courier" color="gray">pat<br>
jim<br>
cindy<br>
ernie<br>
stephanie<br>
brian<br>
bert<br>
susan<br>
randy<br>
leonard<br>
philip<br>
terry<br>
kathy<br>
evan<br>
jacob</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">SortLines<br>
PadLinesRight ' ' /w15<br>
JoinLines 3</font></p>

<p>will output three columns of names:</p>

<p><font size="1" face="Courier" color="gray">bert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; brian&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cindy<br>
ernie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;evan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jacob<br>
jim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kathy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leonard<br>
pat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;philip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; randy<br>
stephanie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;susan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terry<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>Notice that the names are ordered across the columns, from left to right. Had we intended for them to be ordered down each column instead, we would need to apply the ColumnOrder filter ahead of the JoinLines filter:</p>

<p><font size="1" face="Courier" color="gray">SortLines<br>
PadLinesRight ' ' /w15<br>
ColumnOrder 5 3<br>
JoinLines 3</font></p>

<p>This produces three columns of names that are ordered down each column:</p>

<p><font size="1" face="Courier" color="gray">bert&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jacob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;philip<br>
brian&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randy<br>
cindy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kathy&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stephanie<br>
ernie&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;leonard&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;susan<br>
evan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terry<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>Note: The number of lines being joined by the JoinLines filter must be the same as the number of columns specified in the ColumnOrder filter.</p>

<p>As a second example of using the ColumnOrder filter, suppose you had a list of names and addresses that you needed to create mailing labels from:</p>

<p><font size="1" face="Courier" color="gray">Jim Philips&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1290 Pin Oak Ln&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Westhaven, FL 77392<br>
Ted Crowder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7382 West 21st St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lincoln, AR 72882<br>
Lisa Taylor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1213 Pompano St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Norden, TX 77283<br>
Laura Michelson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1550 Fenn Way Blvd.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treeville, CO 77662<br>
Peter Piper&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8399 Fourth St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ashton, CT 72882<br>
William Orson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7113 France Ave.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linden KY 66383<br>
Susan Simpson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;728 Conner Peak St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Freemont IN, 45892<br>
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----</font></p>

<p>If your label stock is one label wide, you could simply execute the following pipe,</p>

<p><font size="1" face="Courier" color="gray">AppendStr '\e'<br>
SplitLines 26 51</font></p>

<p>to obtain the desired output:</p>

<p><font size="1" face="Courier" color="gray">Jim Philips<br>
1290 Pin Oak Ln<br>
Westhaven, FL 77392</font></p>

<p><font size="1" face="Courier" color="gray">Ted Crowder<br>
7382 West 21st St.<br>
Lincoln, AR 72882</font></p>

<p><font size="1" face="Courier" color="gray">Lisa Taylor<br>
1213 Pompano St.<br>
Norden, TX 77283</font></p>

<p><font size="1" face="Courier" color="gray">Laura Michelson<br>
1550 Fenn Way Blvd.<br>
Treeville, CO 77662</font></p>

<p><font size="1" face="Courier" color="gray">Peter Piper<br>
8399 Fourth St.<br>
Ashton, CT 72882</font></p>

<p>...</p>

<p>The AppendStr filter is used to first double-space the list of names and the SplitLines filter then splits each line into three separate lines. Note that the SplitLines filter doesn't affect the blank lines as their length, (0) is less than the column positions 26 and 51 at which splitting takes place.</p>

<p>Now, suppose you wanted the labels to be printed on a laser printer, 3 across by say, 15 deep per page. Adding three more filters to the original pipe gives us the pipe:</p>

<p><font size="1" face="Courier" color="gray">AppendStr '\e'<br>
SplitLines 26 51<br>
PadLinesRight ' ' /w25<br>
ColumnOrder 12 3<br>
JoinLines 3</font></p>

<p>Its execution delivers the following output:</p>

<p><font size="1" face="Courier" color="gray">Jim Philips&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Laura Michelson&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Susan Simpson<br>
1290 Pin Oak Ln&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1550 Fenn Way Blvd.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;728 Conner Peak St.<br>
Westhaven, FL 77392&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treeville, CO 77662&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Freemont IN, 45892</font></p>

<p><font size="1" face="Courier" color="gray">Ted Crowder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Peter Piper<br>
7382 West 21st St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8399 Fourth St.<br>
Lincoln, AR 72882&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ashton, CT 72882</font></p>

<p><font size="1" face="Courier" color="gray">Lisa Taylor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;William Orson<br>
1213 Pompano St.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7113 France Ave.<br>
Norden, TX 77283&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Linden KY 66383<br>
----+----1----+----2----+----3----+----4----+----5----+----6----+----7</font></p>

<p>In this particular example, I limited the output to 3 labels deep by specifying 12 rows in the ColumnOrder filter instead of the 28 that would be required for a single column, (7 labels x 4 lines per label). This allowed the output to span 3 columns for the sake of demonstration.</p>

<a name="CountChars"><h3>CountChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">CountChars /I&lt;char pos&gt; /L /W&lt;width&gt; /Z</font><br>
<font size="1">summary: </font><font size="1" color="gray">outputs the number of characters</font></p>

<p>The CountChars filter outputs the total number of characters in the input text. If the /L switch is specified then the total number of characters per each line is output instead. If the /I switch is specified along with the /L switch then each line's total is inserted back into the line at the specified character position. The /W switch determines the width of the resulting numeric value(s) and the /Z switch causes them to be displayed with leading zeros. Given the following text,</p>

<p><font size="1" face="Courier" color="gray">The CountChars filter<br>
outputs the total number<br>
of characters in<br>
the input text.</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">CountChars</font></p>

<p>will return:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;&nbsp;&nbsp;76</font></p>

<p>Note: If the /I switch is specified without the /L switch, it will be ignored.</p>

<p>See also CountLines</p>

<a name="CountLines"><h3>CountLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">CountLines /W&lt;width&gt; /Z</font><br>
<font size="1">summary: </font><font size="1" color="gray">outputs the number of lines</font></p>

<p>The CountLines filter outputs the total number of lines in the input text. The /W switch determines the width of the resulting numeric value and the /Z switch causes the count to be displayed with leading zeros. Given the following text,</p>

<p><font size="1" face="Courier" color="gray">The CountLines filter<br>
outputs the total number<br>
of lines in<br>
the input text.</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">CountLines /w3 /z</font></p>

<p>will return:</p>

<p><font size="1" face="Courier" color="gray">004</font></p>

<p>See also CountChars</p>

<a name="CullLines"><h3>CullLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">CullLines &lt;begin string&gt; &lt;end string&gt; /A /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes groups of lines encountered in the input text</font></p>

<p>The CullLines filter removes from output the first group of lines encountered in the input text in which the initial line of the group contains the &lt;begin string&gt; and the last line of the group contains the &lt;end string&gt;. If the /A switch is specified, all such groups encountered in the input text will be removed. If the /I switch is specified, case is ignored in locating the "boundary" strings in the input text. If the /R switch is specified the strings are treated as regular expression patterns. If both strings are found on the same line, then only that line will be removed. Given the following text,</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick brown<br>
fox<br>
jumped<br>
over the lazy<br>
dog and<br>
the lazy<br>
dog<br>
didn't even bark</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">CullLines 'fox' 'lazy'</font></p>

<p>will result in:</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick brown<br>
dog and<br>
the lazy<br>
dog<br>
didn't even bark</font></p>

<p>Note: The CullLines filter performs the opposite function of the ExtractLines filter which outputs the text between the two strings instead of removing the text.</p>

<p>See also ExtractLines</p>

<a name="DecToBase"><h3>DecToBase</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DecToBase &lt;radix&gt; /I&lt;ins char pos&gt; /S&lt;scan char pos&gt; /W&lt;width&gt; /Z</font><br>
<font size="1">summary: </font><font size="1" color="gray">converts decimal numbers found in the input text to another base</font></p>

<p>The DecToBase filter converts decimal, (base 10) numbers found in the input text to another base, (2 - 62) and then outputs the resulting values. The only required parameter is the radix of the numbers being converted to. If an insert character position is specified using the /I switch the resulting decimal values will be inserted into the output text at the specified character position rather than being output alone. The /S switch can be used to specify the character position where scanning for the input (decimal) values begins. If the /S switch is omitted, scanning begins at character position 1. The /W switch determines the width of the numeric result. The /Z switch causes the value(s) to be displayed with leading zeros.</p>

<p>Given a single input line of text containing the characters "255" (a decimal value), the following pipe will convert it to&nbsp;&nbsp;"FF", (base 16 or hexadecimal):</p>

<p><font size="1" face="Courier" color="gray">DecToBase 16</font></p>

<p>As the filters, BaseToDec and DecToBase can convert to and from decimal, they can be combined to allow conversion from any base to any other base, (2 - 62).&nbsp;&nbsp;For example, the following pipe could be used to convert the value "1010" (in binary) to "A" (hexadecimal):</p>

<p><font size="1" face="Courier" color="gray">BaseToDec<br>
DecToBase 16</font></p>

<p>See also BaseToDec</p>

<a name="DelBlankLines"><h3>DelBlankLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DelBlankLines</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes blank lines from output</font></p>

<p>The DelBlankLines filter filters all blank lines. A blank line is considered to be one that contains no characters. A line containing just blank or tab characters is NOT considered a blank line. In order to remove lines containing only blank or tab characters, the TrimLines or TrimLinesRight filters must first be used to remove the whitespace.</p>

<p>Given the following 3 lines of text -- the 2nd of which is blank,</p>

<p><font size="1" face="Courier" color="gray">This line is not blank</font></p>

<p><font size="1" face="Courier" color="gray">This line is also not blank</font></p>

<p>...the pipe,</p>

<p><font size="1" face="Courier" color="gray">DelBlankLines</font></p>

<p>...will output the non-blank lines only:</p>

<p><font size="1" face="Courier" color="gray">This line is not blank<br>
This line is also not blank</font></p>

<p>See also DelExtraBlankLines</p>

<a name="DelChars"><h3>DelChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DelChars &lt;char pos&gt; &lt;no of chars&gt; [&lt;char pos&gt; &lt;no of chars&gt;...]</font><br>
<font size="1">summary: </font><font size="1" color="gray">deletes characters from each line at specified character positions</font></p>

<p>The DelChars filter deletes a specified number of characters from each line at a given character position. Multiple deletions may be performed, however the position parameters must be in ascending order.</p>

<p>To illustrate the DelChars filter, suppose you wanted to delete the 2nd and 4th columns from the following fixed-width data:</p>

<p><font size="1" face="Courier" color="gray">54667&nbsp;&nbsp;Tiny Tim&nbsp;&nbsp;&nbsp;&nbsp; 05/05/1980&nbsp;&nbsp;M&nbsp;&nbsp; 20456.45&nbsp;&nbsp; 2347281749<br>
87896&nbsp;&nbsp;John Doe&nbsp;&nbsp;&nbsp;&nbsp; 01/15/1960&nbsp;&nbsp;M&nbsp;&nbsp; 234888.56&nbsp;&nbsp;6482610982<br>
98798&nbsp;&nbsp;Lex Luther&nbsp;&nbsp; 05/26/1940&nbsp;&nbsp;M&nbsp;&nbsp; 9834.01&nbsp;&nbsp;&nbsp;&nbsp;4566281737<br>
67491&nbsp;&nbsp;Betty Boop&nbsp;&nbsp; 05/26/1932&nbsp;&nbsp;F&nbsp;&nbsp; 34772.01&nbsp;&nbsp; 1902630722<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>The pipe,</p>

<p><font size="1" face="Courier" color="gray">DelChars 8 13 33 4</font></p>

<p>delivers the desired results:</p>

<p><font size="1" face="Courier" color="gray">54667&nbsp;&nbsp;05/05/1980&nbsp;&nbsp;20456.45&nbsp;&nbsp; 2347281749<br>
87896&nbsp;&nbsp;01/15/1960&nbsp;&nbsp;234888.56&nbsp;&nbsp;6482610982<br>
98798&nbsp;&nbsp;05/26/1940&nbsp;&nbsp;9834.01&nbsp;&nbsp;&nbsp;&nbsp;4566281737<br>
67491&nbsp;&nbsp;05/26/1932&nbsp;&nbsp;34772.01&nbsp;&nbsp; 1902630722<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Note: To reorder the columns in addition to removing some of them, see the SubStr filter.</p>

<p>See also StripChars, SubStr</p>

<a name="DelCharsToStr"><h3>DelCharsToStr</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DelCharsToStr &lt;string&gt; /I /N&lt;count&gt; /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">deletes characters until string is encountered</font></p>

<p>The DelCharsToStr filter removes characters from a line until the given string, if found, is relocated to the beginning of the line. If the string is not found in a line, no editing is done to that line. DelCharsToStr can accept a /N switch specifying the number of strings to "index". By default, this is 1. If you specify a count that is greater than the number of occurences of that string in a line, then the line will not be edited.&nbsp;&nbsp;If the /I switch is specified the case of the strings is ignored. If the /R switch is specified the strings are treated as a regular expression patterns.</p>

<p>Like with ShiftChars and RotCharsToStr, the DelCharsToStr filter can be very useful for editing all the lines of input text as a whole (rather than each line individually).&nbsp;&nbsp;This is done by preprocessing the text onto a single line first using the JoinLines filter.&nbsp;&nbsp;Suppose you wanted to remove the third line of the following text:</p>

<p><font size="1" face="Courier" color="gray">This is line one.<br>
This is line two.<br>
This is line three.<br>
This is line four.</font></p>

<p>This can be achieved using the DelCharsToStr filter using the following pipe:</p>

<p><font size="1" face="Courier" color="gray">AppendStr '&lt;eol&gt;'<br>
JoinLines<br>
InsStr 1 '&lt;bot&gt;'<br>
RotCharsToStr '&lt;eol&gt;' /n2<br>
DelCharsToStr '&lt;eol&gt;' /n2<br>
RotCharsToStr '&lt;bot&gt;'<br>
ReplStr '&lt;bot&gt;' '' '&lt;eol&gt;' '\e'</font></p>

<p>Granted, this could be done more easily using the ExclLines filter; however, there are times when the above technique is better suited; for example, when manipulating free-form text where "lines" of text are not so well defined, (i.e. HTML). For an example, see the demo, "Edit HTML Files".</p>

<p>See also ShiftChars</p>

<a name="DelDuplLines"><h3>DelDuplLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DelDuplLines [&lt;char pos&gt; &lt;char pos&gt;] /A /D&lt;delimiter&gt; /I</font><br>
<font size="1">summary: </font><font size="1" color="gray">acts on sorted lists removing all duplicate lines</font></p>

<p>The DelDuplLines filter acts on sorted lists, removing any extraneous duplicate lines (thus, outputting only a single line for each set of duplicate lines). If the /A switch is added, all lines are removed from each set of duplicate lines. If the /I switch is specified, case is ignored in determining uniqueness. If a delimiter is specified using the /D switch, then duplication is based on the text at the beginning of each line up to the delimiter. You can also specify a range of character positions upon which duplication is determined. See the OutDuplLines filter for an example use of the DelDuplLines filter.</p>

<p>Note: In order for the DelDuplLines filter to work, the input text must be sorted. If removing duplicates based on a range of character positions, the input text must be sorted on that same range of character positions.</p>

<p>Note: Either a range or a delimiter should be specified, but not both.</p>

<p>See also SortLines, OutDuplLines</p>

<a name="DelExtraBlankLines"><h3>DelExtraBlankLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DelExtraBlankLines</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes extraneous blank lines</font></p>

<p>The DelExtraBlankLines filter removes extraneous blank lines. It replaces any number of consecutive blank lines with a single one. Note that to be considered blank, a line must contain absolutely no characters, not even blanks or tab characters; therefore, it may be necessary to remove trailing blanks and tabs from all lines first, (using either the TrimLines or TrimLinesRight filters) before the DelExtraBlankLines filter is used.</p>

<p>See also DelBlankLines</p>

<a name="DelExtraBlanks"><h3>DelExtraBlanks</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DelExtraBlanks</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes extraneous blanks from each line</font></p>

<p>The DelExtraBlanks filter removes all extraneous blanks from each line. It replaces any number of consecutive blanks with a single one.</p>

<p>Note: The DelExtraBlanks has no effect on tab characters.</p>

<a name="DivValues"><h3>DivValues</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">DivValues &lt;char pos&gt; &lt;char pos&gt; /I&lt;ins char pos&gt; /W&lt;width&gt; /D&lt;decimals&gt; /S</font><br>
<font size="1">summary: </font><font size="1" color="gray">performs division with two numbers in the input text</font></p>

<p>The DivValues filter divides two numbers found in each input line and outputs the result of the division per each line. The two required parameters specify at what character positions the numbers involved in the division are located and in each case must point at the leftmost digit of the number or at the white space prior to it. If the /I switch is specified, the result of the division is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.</p>

<p>Given input text containing the two columns of numbers:</p>

<p><font size="1" face="Courier" color="gray">100&nbsp;&nbsp;20<br>
20&nbsp;&nbsp;&nbsp;&nbsp;5<br>
----+----1----+----2</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">DivValues 1 5</font></p>

<p>will result in:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;5.00<br>
&nbsp;&nbsp;4.00<br>
----+----1----+----2</font></p>

<p>Adding the /I switch,</p>

<p><font size="1" face="Courier" color="gray">DivValues 1 5 /i10</font></p>

<p>causes the result of the division to be inserted back into each line, in this case at character position 10:</p>

<p><font size="1" face="Courier" color="gray">100&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;5.00<br>
20&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;4.00<br>
----+----1----+----2</font></p>

<a name="EndIsolate"><h3>EndIsolate</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">EndIsolate</font><br>
<font size="1">summary: </font><font size="1" color="gray">used with IsolateLines to constrain pipe commands to an isolated block of text</font></p>

<p>The EndIsolate filter is used along with IsolateLines to constrain pipe commands to an isolated block of text.&nbsp;&nbsp;For an example, see IsolateLines.</p>

<a name="ExclLines"><h3>ExclLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ExclLines &lt;string&gt; [&lt;begin char pos&gt; &lt;end char pos&gt;] /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">excludes all lines from output that contain the specified string</font></p>

<p>The Excllines filter filters all lines that contain the specified string. If the optional range of character positions is specified, then lines are excluded only if the string exists within that range of character positions. If the /I switch is specified then the case of the string is ignored. If the /R switch is specified the string is treated as a regular expression pattern.</p>

<p>For example,</p>

<p><font size="1" face="Courier" color="gray">ExclLines 'the' 5 7</font></p>

<p>...will remove all lines from output that contain the string 'the' in character positions 5 through 7.</p>

<p>Note: The InclLines filter performs the opposite function of ExclLines.</p>

<p>See also InclLines</p>

<a name="ExtractLines"><h3>ExtractLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ExtractLines &lt;begin string&gt; &lt;end string&gt; /A /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">extracts groups of lines encountered in the input text</font></p>

<p>The ExtractLines filter extracts the first group of lines encountered in the input text in which the initial line of the group contains the &lt;begin string&gt; and the last line of the group contains the &lt;end string&gt;. If the /A switch is specified, all such groups encountered in the input text will be extracted. If the /I switch is specified, case is ignored in locating the "boundary" strings in the input text. If the /R switch is specified the strings are treated as regular expression patterns. If both strings are found on the same line, then only that line will be extracted. Given the following text,</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick brown<br>
fox<br>
jumped<br>
over the lazy<br>
dog and<br>
the lazy<br>
dog<br>
didn't even bark</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">ExtractLines 'fox' 'lazy'</font></p>

<p>will result in:</p>

<p><font size="1" face="Courier" color="gray">fox<br>
jumped<br>
over the lazy</font></p>

<p>Note: The ExtractLines filter performs the opposite function of CullLines which removes the text between the two strings instead of passing the text.</p>

<p>See also CullLines</p>

<a name="FoldLines"><h3>FoldLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">FoldLines [&lt;char pos&gt; &lt;char pos&gt;] /D&lt;delimiter&gt; /E /I /J&lt;join opt&gt; /W&lt;width&gt; /Z</font><br>
<font size="1">summary: </font><font size="1" color="gray">acts on sorted lists folding duplicate lines</font></p>

<p>The FoldLines filter acts on sorted lists, folding any duplicate lines (outputting just a single line for each group of duplicate lines along with an appended count). If a range of character positions is specified then uniqueness is determined based on that range only. Likewise, if a delimiter character is specified using the /D switch, uniqueness is determined based on the text found at the beginning of each line up to the delimiter. If the /I switch is specified, case is ignored in determining uniqueness. If the /E switch is specified, input lines are expected to already have a count appended (by default, input lines have an implicit count of "1"). A join option can be specified using the /J switch. A join option of 0 (the default) causes output of a single line plus a count for each group of duplicate lines. Use of join option causes each group of duplicate lines to be joined onto one line. Join option 2 simply combines join options 0 and 1.</p>

<p>Note: In order for the FoldLines filter to work, the input text must be sorted. If folding duplicates based on a range of character positions, the input text must be sorted on that same range of character positions.</p>

<p>Note: Either a range or a delimiter should be specified, but not both.</p>

<p>See also JoinLines</p>

<a name="GroupLines"><h3>GroupLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">GroupLines &lt;string&gt; [&lt;begin char pos&gt; &lt;end char pos&gt;] /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">groups lines together that contain a string</font></p>

<p>The GroupLines filter simply groups all lines containing the given string at the end of the text. It is primarily intended for use as a "pre-filter" to the IsolateLines filter as that filter expects to work with contiguous blocks of text.&nbsp;&nbsp;If the optional character position range is specified, then only that segment of each input line of text is considered when searching for the string. If the /I switch is specified then the case of the string is ignored. If the /R switch is specified the string is treated as a regular expression pattern.&nbsp;&nbsp;For an example using the GroupLines filter, see IsolateLines.</p>

<a name="InclLines"><h3>InclLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">InclLines &lt;string&gt; [&lt;begin char pos&gt; &lt;end char pos&gt;] /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">includes all lines in the output that contain the specified string</font></p>

<p>The InclLines filter outputs all lines that contain the specified string. If the optional range of character positions is specified, then lines are output only if the string exists within that range of character positions. If the /I switch is specified then the case of the string is ignored. If the /R switch is specified the string is treated as a regular expression pattern.</p>

<p>For example, the pipe,</p>

<p><font size="1" face="Courier" color="gray">InclLines 'the' 5 7</font></p>

<p>...will output all lines that contain the string 'the' in character positions 5 through 7.</p>

<p>Note: The ExclLines filter performs the opposite function of InclLines.</p>

<p>See also ExclLines</p>

<a name="InsLineNo"><h3>InsLineNo</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">InsLineNo /L&lt;init no&gt; /I&lt;incr&gt; /P&lt;ins pos&gt; /S&lt;no of lines&gt; /W&lt;width&gt; /Z</font><br>
<font size="1">summary: </font><font size="1" color="gray">inserts a line number at the specified character position of each line</font></p>

<p>The InsLineNo filter inserts a line number into each line. The line number is inserted at the beginning of each line unless the /P switch specifies that the line number is to be inserted at another character position. You can use the /L switch to specify the initial line number which can be a negative number. By default it is 1. Specify a /I switch if you want the line numbers to increment by some integer value other than the default which is 1, (it can be a negative number as well). Specify a /S switch if you want the line number sequence to repeat every specified number of lines. The default is 0 meaning that no repetition occurs. The /W switch determines the width of each line number. If not specified, the default numeric width, 6 is used. If the /Z switch is specified, the line numbers will be left-padded with zeros.</p>

<p>As an example, supposed we had the following list of names,</p>

<p><font size="1" face="Courier" color="gray">John<br>
Susan<br>
Paul<br>
George</font></p>

<p>... and for whatever reason, we wanted to vertically "flip" them. This is easily done using the InsLineNo filter in combination with SortLines:</p>

<p><font size="1" face="Courier" color="gray">InsLineNo /w6 /z<br>
SortLines /r<br>
DelChars 1 6</font></p>

<p>Execution of this pipe results in the expected output:</p>

<p><font size="1" face="Courier" color="gray">George<br>
Paul<br>
Susan<br>
John</font></p>

<p>Note: The InsLineNo filter is typically used as a pre-filter to record the current "order" of the input text prior to subsequent processing by other filters which may reorder the text as part of their processing. This allows the lines of text to later be sorted back to their original order. For an example where the InsLineNo filter is used for this purpose see the IsolateLines filter.</p>

<a name="InsStr"><h3>InsStr</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">InsStr &lt;char pos&gt; &lt;string&gt; [&lt;char pos&gt; &lt;string&gt;...]</font><br>
<font size="1">summary: </font><font size="1" color="gray">inserts character strings into each line at specified character positions</font></p>

<p>The InsStr filter inserts a character string into each line at the specified character position. Multiple insertions into each line may be performed however the character position parameters must be in ascending order.</p>

<p>Given the following list of batch files,</p>

<p><font size="1" face="Courier" color="gray">convert.bat<br>
this.bat<br>
that.bat<br>
theother.bat</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">InsStr 1 'c:\\temp\\' 15 '"a command line argument"'</font></p>

<p>will output:</p>

<p><font size="1" face="Courier" color="gray">c:\temp\convert.bat&nbsp;&nbsp; "a command line argument"<br>
c:\temp\this.bat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"a command line argument"<br>
c:\temp\that.bat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"a command line argument"<br>
c:\temp\theother.bat&nbsp;&nbsp;"a command line argument"<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>See also AppendStr, OverlayChars</p>

<a name="IsolateLines"><h3>IsolateLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">IsolateLines &lt;string&gt; [&lt;begin char pos&gt; &lt;end char pos&gt;] /Es /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">used along with EndIsolate to constrain pipe commands to isolated block of text</font></p>

<p>To illustrate text isolation, suppose we had three "records" of data, each one consisting of 4 fields: name, age, city and state, all contained on separate lines:</p>

<p><font size="1" face="Courier" color="gray">John L. Doe<br>
42<br>
Miami<br>
FL<br>
Frank N. Stein<br>
20<br>
Los Angeles<br>
CA<br>
Norma Lee<br>
16<br>
Austin<br>
TX</font></p>

<p>Now, suppose we wanted to uppercase just those lines containing the person's name, leaving all of the other lines unchanged. This is a simple matter although it requires that the targeted text be isolated first. Text isolation takes advantage of the fact that the targeted lines are somehow distinguishable from other lines. To this end, our first order of business is to use the InsLineNo filter to add line numbers (that repeat every four lines) to the lines of text. This will later allow us to isolate all of those lines that begin with a "1".</p>

<p><font size="1" face="Courier" color="gray">InsLineNo /w1 /s4</font></p>

<p>Next, since text isolation changes the line order of the text, we must use the InsLineNo filter again--this time to record the line order of the current text. Here, the line number doesn't repeat and its 2 characters wide with leading zeros.</p>

<p><font size="1" face="Courier" color="gray">InsLineNo /w2 /z</font></p>

<p>Now we're almost ready to isolate the text; however, text isolation only works if the targeted lines (those being isolated) are grouped together in the text. Here, we use the GroupLines filter to group all lines that begin with a "1" at the end of the text.</p>

<p><font size="1" face="Courier" color="gray">GroupLines '1' 3 3</font></p>

<p>Now we can isolate the targeted text. This is done simply by specifying the IsolateLines filter with the same arguments as the GroupLines filter did prior.</p>

<p><font size="1" face="Courier" color="gray">IsolateLines '1' 3 3</font></p>

<p>At this point the tageted lines are isolated. In other words, any filters enclosed inside of the IsolateLines and EndIsolate filters will only operate on these targeted lines of text. As such, all we need to do now is apply the UpperCase filter:</p>

<p><font size="1" face="Courier" color="gray">UpperCase</font></p>

<p>Although the targeted lines are now uppercased like we wanted, they now must be integrated back into the original text. This is done by use of the EndIsolate filter.</p>

<p><font size="1" face="Courier" color="gray">EndIsolate</font></p>

<p>The targeted lines are now integrated into the original text but they are still grouped at the end of it. By sorting the text the edited lines are "ungrouped" back to their original positions:</p>

<p><font size="1" face="Courier" color="gray">SortLines</font></p>

<p>Finally, we remove the double line numbers that were added at the beginning and we're done:</p>

<p><font size="1" face="Courier" color="gray">DelChars 1 3</font></p>

<p>Here's the completed pipe,</p>

<p><font size="1" face="Courier" color="gray">InsLineNo /w1 /s4<br>
InsLineNo /w2 /z<br>
GroupLines '1' 3 3<br>
IsolateLines '1' 3 3<br>
&nbsp;&nbsp; UpperCase<br>
EndIsolate<br>
SortLines<br>
DelChars 1 3</font></p>

<p>... and its resulting output:</p>

<p><font size="1" face="Courier" color="gray">JOHN L. DOE<br>
42<br>
Miami<br>
FL<br>
FRANK N. STEIN<br>
20<br>
Los Angeles<br>
CA<br>
NORMA LEE<br>
16<br>
Austin<br>
TX</font></p>

<p>Note: As you may have guessed, it's possible using this technique to edit a single "column" of the input text as well. One merely has to translate the columns into rows first (for example, by using the SplitLines filter) and then, after the editing is done, translate the rows back to columns.&nbsp;&nbsp;For example, given the text,</p>

<p><font size="1" face="Courier" color="gray">smoky&nbsp;&nbsp; bear&nbsp;&nbsp;&nbsp;&nbsp;says<br>
only&nbsp;&nbsp;&nbsp;&nbsp;you&nbsp;&nbsp;&nbsp;&nbsp; can<br>
prevent forest&nbsp;&nbsp;fires<br>
----+----1----+----2----+</font></p>

<p>... you could use the following pipe to uppercase just those words that are in column two--"bear", "you" and "forest" (try it):</p>

<p><font size="1" face="Courier" color="gray">SplitLines 9 17<br>
InsLineNo /w1 /s3<br>
InsLineNo /w2 /z<br>
GroupLines '2' 3 3<br>
IsolateLines '2' 3 3<br>
&nbsp;&nbsp; UpperCase<br>
EndIsolate<br>
SortLines<br>
DelChars 1 3<br>
JoinLines 3</font></p>

<p>The resulting text is:</p>

<p><font size="1" face="Courier" color="gray">smoky&nbsp;&nbsp; BEAR&nbsp;&nbsp;&nbsp;&nbsp;says<br>
only&nbsp;&nbsp;&nbsp;&nbsp;YOU&nbsp;&nbsp;&nbsp;&nbsp; can<br>
prevent FOREST&nbsp;&nbsp;fires</font></p>

<a name="JoinLines"><h3>JoinLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">JoinLines [&lt;no of lines&gt;] /P</font><br>
<font size="1">summary: </font><font size="1" color="gray">joins every n lines of text into a single line of text</font></p>

<p>The JoinLines filter combines all lines in the input text onto a single line, in-effect removing all end-of-lines from the input text. If the optional number of lines parameter is specified then that many lines will be combined onto each line output. The /P switch is used to join all of the lines within each "paragraph" (a sequence of non-blank lines) onto a single line and is ignored if the &lt;number of lines&gt; parameter is specified.</p>

<p>Warning: JoinLines is the key to some of the more advanced piping techniques; however, be forewarned that it is VERY costly from a performance perspective. Try to limit the number of lines of text that are input to the JoinLines filter whenever possible by filtering unneeded text lines prior to its execution.</p>

<p>To illustrate use of JoinLines, consider the following text which represents three data records, each containing a name, age, city and state:</p>

<p><font size="1" face="Courier" color="gray">John L. Doe<br>
42<br>
Miami<br>
FL<br>
Frank N. Stein<br>
20<br>
Los Angeles<br>
CA<br>
Norma Lee<br>
16<br>
Austin<br>
TX</font></p>

<p>Normally, you wouldn't encounter data records in this form; however, it is quite common to do so when working with pipes. To transform the above text to the more conventional form, you'd employ the following pipe:</p>

<p><font size="1" face="Courier" color="gray">AppendStr ','<br>
JoinLines 4<br>
StripChars 1</font></p>

<p>When executed, it results in the following comma-delimited data:</p>

<p><font size="1" face="Courier" color="gray">John L. Doe,42,Miami,FL<br>
Frank N. Stein,20,Los Angeles,CA<br>
Norma Lee,16,Austin,TX</font></p>

<p>Note: For a more practical example in which fixed-width data is translated to comma-delimited data (which uses the JoinLines filter), see the QuoteLines filter.</p>

<p>Next up, given you have multiple paragraphs of text:</p>

<p><font size="1" face="Courier" color="gray">This is the<br>
first paragraph of text<br>
contained on three lines.</font></p>

<p><font size="1" face="Courier" color="gray">This is the second<br>
paragraph of text contained on two lines.</font></p>

<p><font size="1" face="Courier" color="gray">This is the third paragraph of text contained on one line.</font></p>

<p>Suppose you want to remove all end-of-lines from each paragraph. The following pipe does the trick:</p>

<p><font size="1" face="Courier" color="gray">AppendStr ' '<br>
JoinLines /p</font></p>

<p>When run, it outputs:</p>

<p><font size="1" face="Courier" color="gray">This is the first paragraph of text contained on three lines.</font></p>

<p><font size="1" face="Courier" color="gray">This is the second paragraph of text contained on two lines.</font></p>

<p><font size="1" face="Courier" color="gray">This is the third paragraph of text contained on one line.</font></p>

<p>Note: For an example in which the JoinLines filter is used to create multiple columns of text from a single column, see the ColumnOrder filter.</p>

<a name="JustCharsLeft"><h3>JustCharsLeft</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">JustCharsLeft [&lt;begin char pos&gt; &lt;end char pos&gt;]</font><br>
<font size="1">summary: </font><font size="1" color="gray">left justifies characters</font></p>

<p>The JustCharsLeft filter left-justifies each line of text. If the optional range of character positions is specified, the filter operates only on that range of characters. For an example of how this works, see JustCharsRight.</p>

<p>See also JustCharsRight.</p>

<a name="JustCharsRight"><h3>JustCharsRight</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">JustCharsRight [&lt;begin char pos&gt; &lt;end char pos&gt;]</font><br>
<font size="1">summary: </font><font size="1" color="gray">right justifies characters</font></p>

<p>The JustCharsRight filter right-justifies each line of text. If the optional range of character positions is specified, the filter operates only on that range of characters. The JustCharsRight filter can be used in combination with the PadLinesRight filter to right-justify entire lines:</p>

<p><font size="1" face="Courier" color="gray">PadLinesRight ' '<br>
JustCharsRight</font></p>

<p>Optionally, JustCharsRight can justify a range of character positions. For example, if you wanted to right-justify just the folder names in the following text,</p>

<p><font size="1" face="Courier" color="gray">06/02/2002&nbsp;&nbsp;02:39p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Documents and Settings&nbsp;&nbsp;Archived<br>
10/28/2002&nbsp;&nbsp;10:16a&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Outlook Mail Messages&nbsp;&nbsp; Archived<br>
05/12/2003&nbsp;&nbsp;05:52p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Program Files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Archived<br>
04/14/2003&nbsp;&nbsp;08:36a&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Trash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Archived<br>
04/01/2003&nbsp;&nbsp;01:55p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;WINNT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Archived<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>... you could call JustCharsRight like this:</p>

<p><font size="1" face="Courier" color="gray">JustCharsRight 28 49</font></p>

<p>This would result in the following:</p>

<p><font size="1" face="Courier" color="gray">06/02/2002&nbsp;&nbsp;02:39p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Documents and Settings&nbsp;&nbsp;Archived<br>
10/28/2002&nbsp;&nbsp;10:16a&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp; Outlook Mail Messages&nbsp;&nbsp;Archived<br>
05/12/2003&nbsp;&nbsp;05:52p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program Files&nbsp;&nbsp;Archived<br>
04/14/2003&nbsp;&nbsp;08:36a&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Trash&nbsp;&nbsp;Archived<br>
04/01/2003&nbsp;&nbsp;01:55p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WINNT&nbsp;&nbsp;Archived<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>The text can easily be restored back to original by passing it through the JustCharsLeft filter like this:</p>

<p><font size="1" face="Courier" color="gray">JustCharsLeft 28 49</font></p>

<p>See also JustCharsLeft.</p>

<a name="LeftChars"><h3>LeftChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">LeftChars &lt;no of chars&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">returns the given number of characters from the beginning of each line of text</font></p>

<p>The LeftChars filter outputs the specified left-most characters from each input line of text.</p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">123.45, Table<br>
061.22, Chair<br>
----+----1----+----2</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">LeftChars 6</font></p>

<p>gives:</p>

<p><font size="1" face="Courier" color="gray">123.45<br>
061.22<br>
----+----1----+----2</font></p>

<p>See also RightChars</p>

<a name="LinesByPos"><h3>LinesByPos</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">LinesByPos &lt;begin line&gt; &lt;end line&gt; [&lt;begin line&gt; &lt;end line&gt;...] /S&lt;no of sets&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">outputs lines according to their position</font></p>

<p>The LinesByPos filter outputs those lines that fall within the specified range of lines. Multiple ranges can be specified but they must be in asending order. For example, 1 3 7 10 16 16 would result in output of lines 1-3, 7-10 and 16. As seen from this example, single lines can be output only by specifying them twice; that is, as a range of one line. If the /S (set) switch is specified then the input source is not viewed as a single continuum of lines 1-n, but rather, as multiple, repeating groups of lines; i.e., 1-&lt;no of sets&gt;, 1-&lt;no of sets&gt;, 1-&lt;no of sets&gt; ... In such case, all specified ranges of lines are output from each group. To illustrate the LinesByPos filter, suppose you wanted to exclude unwanted fields from the comma-delimited text:</p>

<p><font size="1" face="Courier" color="gray">54667,Tiny Tim,05/05/1980,M<br>
87896,John Doe,01/15/1960,M<br>
98798,Lex Luther,05/26/1940,M</font></p>

<p>You might want, for example, to exclude the first and last fields of each line leaving only the person's name and birthdate. To do this, first you need to parse each line's fields onto separate lines. One way to accomplish this is by using the ReplStr filter to replace the commas with end-of-lines:</p>

<p><font size="1" face="Courier" color="gray">ReplStr ',' '\e'</font></p>

<p>Execution of this one-filter pipe gives us the following:</p>

<p><font size="1" face="Courier" color="gray">54667<br>
Tiny Tim<br>
05/05/1980<br>
M<br>
87896<br>
John Doe<br>
01/15/1960<br>
M<br>
98798<br>
Lex Luther<br>
05/26/1940<br>
M</font></p>

<p>Note: The ReplStr filter will not work if the comma-delimited data includes quoted strings that can contain commas. In such a case the ParseCSV filter is recommended instead.</p>

<p>Next, in order to exclude all fields except name and birthdate, the LinesByPos filter is added:</p>

<p><font size="1" face="Courier" color="gray">ReplStr ',' '\e'<br>
LinesByPos 2 3 /s4</font></p>

<p>This gives us:</p>

<p><font size="1" face="Courier" color="gray">Tiny Tim<br>
05/05/1980<br>
John Doe<br>
01/15/1960<br>
Lex Luther<br>
05/26/1940</font></p>

<p>Finally, we add three more filters:</p>

<p><font size="1" face="Courier" color="gray">ReplStr ',' '\e'<br>
LinesByPos 2 3 /s4<br>
AppendStr ','<br>
JoinLines 2<br>
StripChars 1</font></p>

<p>These added filters restore the commas, join the lines (in groups of 2) and then strip off the extraneous commas on the end of each line, giving us the output we desire:</p>

<p><font size="1" face="Courier" color="gray">Tiny Tim,05/05/1980<br>
John Doe,01/15/1960<br>
Lex Luther,05/26/1940</font></p>

<p>Outputting a range of lines from a list according to position can also be accomplished by use of the TopLines and BottomLines filters. See BottomLines for an example of this.</p>

<p>See also BottomLines, TopLines</p>

<a name="LowerCase"><h3>LowerCase</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">LowerCase</font><br>
<font size="1">summary: </font><font size="1" color="gray">converts uppercase characters to lowercase</font></p>

<p>The LowerCase filter converts uppercase characters to lowercase.</p>

<p>See also UpperCase</p>

<a name="MultValues"><h3>MultValues</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">MultValues [&lt;char pos&gt;...] /I&lt;ins char pos&gt; /W&lt;width&gt; /D&lt;decimals&gt; /S</font><br>
<font size="1">summary: </font><font size="1" color="gray">multiplies two or more numbers in the input text</font></p>

<p>The MultValues filter multiplies two or more numbers found in each input line and outputs the result of the multiplication per each line. Each parameter supplied is the character position of a number to be multiplied and in each case it must point at the left-most digit of the number to be multiplied or at the white space prior to it. Alternately, if no parameters are specified then each input line of text is expected to contain numeric values separated by whitespace, If the /I switch is specified, the result of each multiplication is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.</p>

<p>Given the four columns of numbers:</p>

<p><font size="1" face="Courier" color="gray">3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; 10<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2&nbsp;&nbsp; 1.8<br>
----+----1----+----2----+----3----+----4</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">MultValues 1 5 15 20</font></p>

<p>will result in:</p>

<p><font size="1" face="Courier" color="gray">240.00<br>
 69.12<br>
----+----1----+----2----+----3----+----4</font></p>

<p>Adding the /I switch,</p>

<p><font size="1" face="Courier" color="gray">MultValues 1 5 15 20 /I30</font></p>

<p>causes the result of the multiplication to be inserted back into each line, in this case at character position 30:</p>

<p><font size="1" face="Courier" color="gray">3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 240.00<br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2&nbsp;&nbsp; 1.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 69.12<br>
----+----1----+----2----+----3----+----4</font></p>

<a name="OutDuplLines"><h3>OutDuplLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">OutDuplLines [&lt;begin char pos&gt; &lt;end char pos&gt;] /D&lt;delimiter&gt; /I</font><br>
<font size="1">summary: </font><font size="1" color="gray">outputs lines that are duplicated in the text</font></p>

<p>The OutDuplLines filter acts on sorted lists and outputs only those lines that are duplicated in the input text. If the optional range of character positions is specified then uniqueness is determined based on that range only. If a delimiter is specified using the /D switch, then uniqueness is based on the text at the beginning of each line up to the delimiter. If the /I switch is specified, case is ignored in determining uniqueness.</p>

<p>Note: In order for the OutDuplLines filter to work, the input text must be sorted. If outputting duplicate lines based on a range of character positions, the input text must be sorted on that same range of character positions.</p>

<p>Note: Either a range or a delimiter should be specified, but not both.</p>

<p>To illustrate, given the following text,</p>

<p><font size="1" face="Courier" color="gray">1&nbsp;&nbsp; 40&nbsp;&nbsp; now<br>
2&nbsp;&nbsp; 34&nbsp;&nbsp; is<br>
3&nbsp;&nbsp; 26&nbsp;&nbsp; the<br>
4&nbsp;&nbsp; 40&nbsp;&nbsp; time<br>
5&nbsp;&nbsp; 48&nbsp;&nbsp; for<br>
6&nbsp;&nbsp; 32&nbsp;&nbsp; all<br>
7&nbsp;&nbsp; 26&nbsp;&nbsp; good<br>
8&nbsp;&nbsp; 88&nbsp;&nbsp; men<br>
9&nbsp;&nbsp; 40&nbsp;&nbsp; to<br>
----+----1----+----2</font></p>

<p>suppose you wanted to obtain a listing of all lines that were duplicated based on the 2-digit numbers in the second column. The pipe,</p>

<p><font size="1" face="Courier" color="gray">SortLines /P5<br>
OutDuplLines 5 6</font></p>

<p>would result in the desired output:</p>

<p><font size="1" face="Courier" color="gray">7&nbsp;&nbsp; 26&nbsp;&nbsp; good<br>
3&nbsp;&nbsp; 26&nbsp;&nbsp; the<br>
1&nbsp;&nbsp; 40&nbsp;&nbsp; now<br>
4&nbsp;&nbsp; 40&nbsp;&nbsp; time<br>
9&nbsp;&nbsp; 40&nbsp;&nbsp; to<br>
----+----1----+----2</font></p>

<p>If, however you just wanted to know which 2-digit numbers were duplicated, you would add an extra couple of filters:</p>

<p><font size="1" face="Courier" color="gray">SortLines /P5<br>
OutDuplLines 5 6<br>
DelDuplLines 5 6<br>
SubStr 5 2</font></p>

<p>This would result in a unique list as follows:</p>

<p><font size="1" face="Courier" color="gray">26<br>
40</font></p>

<p>See also DelDuplLines, SortLines</p>

<a name="OverlayChars"><h3>OverlayChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">OverlayChars &lt;char pos&gt; &lt;string&gt; [&lt;char pos&gt; &lt;string&gt;...]</font><br>
<font size="1">summary: </font><font size="1" color="gray">overlays each line with character strings at specified character positions</font></p>

<p>The OverlayChars filter overlays each line at the specified character position with a string. Multiple overlays can be performed at the same time. Given the text,</p>

<p><font size="1" face="Courier" color="gray">23.6 123 19.77<br>
12.1 223 20.50<br>
----+----1----+----2</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">OverlayChars 5 ',' 9 ','</font></p>

<p>gives:</p>

<p><font size="1" face="Courier" color="gray">23.6,123,19.77<br>
12.1,223,20.50<br>
----+----1----+----2</font></p>

<p>See also InsStr, AppendStr</p>

<a name="PadLinesLeft"><h3>PadLinesLeft</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">PadLinesLeft &lt;pad string&gt; /W&lt;pad width&gt; /S&lt;no of sets&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">pads each line on the left to the given character width with the given character string</font></p>

<p>The PadLinesLeft filter pads each line on the left with the given character string to the width of the longest line. If the /W switch is specified then all lines are padded to that width instead. If the /S switch is specified then each line is padded to the width of the longest line in its set.</p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick brown<br>
fox<br>
jumped<br>
over the lazy<br>
dog and<br>
the lazy<br>
dog<br>
didn't even bark</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">PadLinesLeft '*'</font></p>

<p>outputs each line padded on the left with asterisks to the width of the longest line:</p>

<p><font size="1" face="Courier" color="gray">*************the<br>
*****quick brown<br>
*************fox<br>
**********jumped<br>
***over the lazy<br>
*********dog and<br>
********the lazy<br>
*************dog<br>
didn't even bark</font></p>

<p>Adding the /S switch gives us the pipe:</p>

<p><font size="1" face="Courier" color="gray">PadLinesLeft '*' /s2</font></p>

<p>Its execution outputs each individual line padded on the left with asterisks to the width of the longest line in its set:</p>

<p><font size="1" face="Courier" color="gray">*************the<br>
quick brown<br>
*************fox<br>
*****jumped<br>
***over the lazy<br>
****dog and<br>
********the lazy<br>
********dog<br>
didn't even bark</font></p>

<p>One reason for wanting to pad lines in this way is in preparation for outputting them as columns. Granted, that could be done without using the /S switch but using it allows the columns to be output will a minimum of space between them. In the case of the PadLinesLeft filter this is best illustrated using numbers. Given the following list of numbers:</p>

<p><font size="1" face="Courier" color="gray">3.33<br>
23455.45<br>
1.20<br>
5345.39<br>
5345345.50<br>
223.11<br>
465456.53<br>
0.54<br>
2352345345.67</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">PadLinesLeft ' ' /s3<br>
AppendStr ' '<br>
JoinLines 3</font></p>

<p>gives us three closely-spaced columns of text, each one neatly right-justified:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;&nbsp;&nbsp; 3.33&nbsp;&nbsp; 23455.45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.20<br>
&nbsp;&nbsp;5345.39 5345345.50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;223.11<br>
465456.53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0.54 2352345345.67<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>Note: The number of sets referenced in the PadLinesLeft filter and the number of lines referenced in the JoinLines filter must be the same for the columns to output properly. To increase the number of output columns simply increase the number of sets in the PadLinesLeft filter and the number of lines in the JoinLines filter.</p>

<p>Note: The /S switch is ignored if a /W switch is specified.</p>

<p>See also PadLinesRight</p>

<a name="PadLinesRight"><h3>PadLinesRight</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">PadLinesRight &lt;pad string&gt; /W&lt;pad width&gt; /S&lt;no of sets&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">pads each line on the right to the given character width with the given character string</font></p>

<p>The PadLinesRight filter pads each line on the right with the given character string to the width of the longest line. If the /W switch is specified then all lines are padded to that width instead. If the /S switch is specified then each line is padded to the width of the longest line in its set.</p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick brown<br>
fox<br>
jumped<br>
over the lazy<br>
dog and<br>
the lazy<br>
dog<br>
didn't even bark</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">PadLinesRight '*'</font></p>

<p>outputs each line padded on the right with asterisks to the width of the longest line:</p>

<p><font size="1" face="Courier" color="gray">the*************<br>
quick brown*****<br>
fox*************<br>
jumped**********<br>
over the lazy***<br>
dog and*********<br>
the lazy********<br>
dog*************<br>
didn't even bark</font></p>

<p>Adding the /S switch gives us the pipe:</p>

<p><font size="1" face="Courier" color="gray">PadLinesRight '*' /s2</font></p>

<p>Its execution outputs each individual line padded on the right with asterisks to the width of the longest line in its set:</p>

<p><font size="1" face="Courier" color="gray">the*************<br>
quick brown<br>
fox*************<br>
jumped*****<br>
over the lazy***<br>
dog and****<br>
the lazy********<br>
dog********<br>
didn't even bark</font></p>

<p>One reason for wanting to pad lines in this way is in preparation for outputting them as columns. Granted, that could be done without using the /S switch but using it allows the columns to be output with a minimum of space between them. Starting with the same text as before, the pipe,</p>

<p><font size="1" face="Courier" color="gray">PadLinesRight ' ' /s3<br>
AppendStr '|'<br>
JoinLines 3</font></p>

<p>gives us three closely-spaced columns of text, each one neatly left-justified and separated by a "|" character:</p>

<p><font size="1" face="Courier" color="gray">the&nbsp;&nbsp;&nbsp;&nbsp; |quick brown&nbsp;&nbsp;|fox&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>
jumped&nbsp;&nbsp;|over the lazy|dog and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>
the lazy|dog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|didn't even bark|<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>Note: The number of sets referenced in the PadLinesRight filter and the number of lines referenced in the JoinLines filter must be the same for the columns to output properly. To increase the number of output columns simply increase the number of sets in the PadLinesRight filter and the number of lines in the JoinLines filter.</p>

<p>Note: The /S switch is ignored if a /W switch is specified.</p>

<p>See also PadLinesLeft</p>

<a name="ParseCSV"><h3>ParseCSV</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ParseCSV /Q&lt;quote&gt; /D&lt;delimiter&gt; /B</font><br>
<font size="1">summary: </font><font size="1" color="gray">parses quoted, comma-delimited fields onto separate lines</font></p>

<p>The ParseCSV filter parses comma-separated data values onto separate lines. Any surrounding quotes are left intact and by default, they are expected to be double-quotes; however, the character expected for quotes can be changed using the /Q switch. Likewise, by default the delimiter character expected to separate fields is a comma but it can be changed using the /D switch. If a quoted string contains embedded quotes then they must be in pairs. For example, """Tiny"" Tim Thompson". Alternatively, if the /B switch is specified, embedded quotes are expected to be represented with the backslash character (\) followed by a quote. For example, "\"Tiny\" Tim Thompson".</p>

<p>Note: ParseCSV expects that data values are either quoted or unquoted. Unquoted values are generally ordinal / numeric values like 56, 1.23 or true. Because whitespace is allowed both before and after delimiters, unquoted data values cannot contain embedded whitespace (actually, they can contain whitespace but it will be removed).</p>

<p>Suppose you wanted to translate the following quoted, comma-delimited data to fixed-width:</p>

<p><font size="1" face="Courier" color="gray">"54667","""Tiny"" Tim","05/05/1980","M",20456.45,"2347281749"<br>
"98798","Luther, Lex","05/26/1940","M",9834.01,"4566281737"<br>
"67491","Betty Boop","05/26/1932","F",34772.01,"1902630722"<br>
----+----1----+----2----+----3----+----4----+----5----+----6----+----7</font></p>

<p>The first step in doing this is to parse all of the comma-separated fields onto separate lines. You could use the ReplStr filter to replace all commas (,) with carriage return / linefeeds, in-effect forcing all fields onto separate lines; however, any of the string fields could contain a comma (as for example, the name "Luther, Lex" in the second line) and therefore this isn't an ideal solution. A better approach is to use the ParseCSV filter instead.</p>

<p>Sending the above data through the one-filter pipe,</p>

<p><font size="1" face="Courier" color="gray">ParseCSV</font></p>

<p>outputs each field onto a separate line:</p>

<p><font size="1" face="Courier" color="gray">"54667"<br>
"""Tiny"" Tim"<br>
"05/05/1980"<br>
"M"<br>
20456.45<br>
"2347281749"<br>
"98798"<br>
"Luther, Lex"<br>
"05/26/1940"<br>
"M"<br>
9834.01<br>
"4566281737"<br>
"67491"<br>
"Betty Boop"<br>
"05/26/1932"<br>
"F"<br>
34772.01<br>
"1902630722"</font></p>

<p>Adding 3 more filters to the pipe gives us:</p>

<p><font size="1" face="Courier" color="gray">ParseCSV<br>
QuoteLines 1 6 /s6 /u<br>
PadLinesRight ' ' /s6<br>
JoinLines 6</font></p>

<p>The /U switch used by the QuoteLines filter is needed to unquote each line, (i.e. remove the outer quotes surrounding each line and then restore any embedded quotes). Finally, the parsed and unquoted fields are padded with blanks using PadLinesRight and then re-joined into fixed-width lines using JoinLines. The final output is:</p>

<p><font size="1" face="Courier" color="gray">54667"Tiny" Tim 05/05/1980M20456.452347281749<br>
98798Luther, Lex05/26/1940M9834.01 4566281737<br>
67491Betty Boop 05/26/1932F34772.011902630722<br>
----+----1----+----2----+----3----+----4----+----5</font></p>

<p>For an example in which fixed-width data is translated to quoted, comma-delimited, see the QuoteLines filter. For an example that illustrates excluding fields from comma-delimited data (in which ParseCSV can be used) see the LinesByPos filter.</p>

<a name="ParseWords"><h3>ParseWords</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ParseWords /D&lt;delimiter&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">parses the text into individual words</font></p>

<p>The ParseWords filter parses each "word" of the input text onto a separate line. By default, a "word" is any text that is delimited by blanks. If you want other characters to be considered as delimiters, you must provide a delimiter string using the /D switch.</p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">Hurry!... Time's a wastin!</font></p>

<p>The pipe,</p>

<p><font size="1" face="Courier" color="gray">ParseWords</font></p>

<p>will produce the following output:</p>

<p><font size="1" face="Courier" color="gray">Hurry!...<br>
Time's<br>
a<br>
wastin!</font></p>

<p>With additional delimiters specified via the /D switch,</p>

<p><font size="1" face="Courier" color="gray">ParseWords /D' !.'''</font></p>

<p>the output becomes:</p>

<p><font size="1" face="Courier" color="gray">Hurry<br>
Time<br>
s<br>
a<br>
wastin</font></p>

<a name="QuoteLines"><h3>QuoteLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">QuoteLines &lt;begin line&gt; &lt;end line&gt; [&lt;begin line&gt; &lt;end line&gt;...] /B /D&lt;delimiter&gt; /O&lt;option&gt; /Q&lt;quote&gt; /S&lt;no of sets&gt; /U</font><br>
<font size="1">summary: </font><font size="1" color="gray">surrounds lines with quotes</font></p>

<p>The QuoteLines filter is a special purpose filter used to translate fixed-width data to quoted, comma-delimited data. It surrounds those lines that fall within the specified range with quotes and replaces each embedded quote with a pair of quotes. If the /B switch is specified then embedded quotes are replaced by a backslash character (\) followed by a quote instead of two quotes. By default, quotes are expected to be double-quotes; however, the character expected for quotes can be changed using the /Q switch. Likewise, by default the delimiter character expected to separate fields is a comma but it can be changed using the /D switch. Multiple ranges can be specified but they must be in asending order. For example, 1 3 7 10 16 16 would result in the quoting of lines 1-3, 7-10 and 16. As seen from this example, single lines can be quoted only by specifying them twice; that is, as a range of one line.&nbsp;&nbsp;If the /S (set) switch is specified then the input source is not viewed as a single continuum of lines 1-n, but rather, as multiple, repeating groups of lines; i.e., 1-&lt;no of sets&gt;, 1-&lt;no of sets&gt;, 1-&lt;no of sets&gt;... In such case, all specified ranges of lines are quoted within each group. The /O (option) switch determines how quoting is performed. It can be specified as one of three values:</p>

<p>&nbsp;&nbsp; 0: Each line in range is quoted unconditionally (default).<br>
&nbsp;&nbsp; 1: Each line in range is quoted only if it contains embedded quotes or delimiters.<br>
&nbsp;&nbsp; 2: Each line in range is quoted only if it constitutes a non-numeric value.</p>

<p>Note: To be considered a numeric value, a line must only contain the characters 0-9.</p>

<p>The /U switch forces the QuoteLines filter to work in reverse. That is, it is used to unquote all lines that fall within the specified range(s). It first removes any outer quotes from each line and then restores embedded quotes. For an example that illustrates use of the /U switch, see the ParseCSV filter.</p>

<p>The following example illustrates use of the QuoteLines filter to translate fixed-width data to quoted, comma-delimited data using option 0. Given the following fixed-width data representing zip code, name, birthdate, sex, account balance and account number,</p>

<p><font size="1" face="Courier" color="gray">54667&nbsp;&nbsp;"Tiny" Tim&nbsp;&nbsp; 05/05/1980&nbsp;&nbsp;M&nbsp;&nbsp; 20456.45&nbsp;&nbsp; 2347281749<br>
87896&nbsp;&nbsp;John Doe&nbsp;&nbsp;&nbsp;&nbsp; 01/15/1960&nbsp;&nbsp;M&nbsp;&nbsp; 234888.56&nbsp;&nbsp;6482610982<br>
98798&nbsp;&nbsp;Luther, Lex&nbsp;&nbsp;05/26/1940&nbsp;&nbsp;M&nbsp;&nbsp; 9834.01&nbsp;&nbsp;&nbsp;&nbsp;4566281737<br>
67491&nbsp;&nbsp;Betty Boop&nbsp;&nbsp; 05/26/1932&nbsp;&nbsp;F&nbsp;&nbsp; 34772.01&nbsp;&nbsp; 1902630722<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">SplitLines 8 21 33 37 48<br>
TrimLinesRight<br>
QuoteLines 1 4 6 6 /s6<br>
AppendStr ','<br>
JoinLines 6<br>
StripChars 1</font></p>

<p>outputs:</p>

<p><font size="1" face="Courier" color="gray">"54667","""Tiny"" Tim","05/05/1980","M",20456.45,"2347281749"<br>
"87896","John Doe","01/15/1960","M",234888.56,"6482610982"<br>
"98798","Luther, Lex","05/26/1940","M",9834.01,"4566281737"<br>
"67491","Betty Boop","05/26/1932","F",34772.01,"1902630722"<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Notice that every column that is in range is quoted unconditionally as per option 0. Here, we omitted the 5th column because we knew that it represented a numeric value. If we know that the target system doesn't require string fields to be quoted unless they contain embedded quotes or delimiters then, instead of the default (0), we could choose option 1 for the QuoteLines filter:</p>

<p><font size="1" face="Courier" color="gray">QuoteLines 1 4 6 6 /s6 /o1</font></p>

<p>This produces the following output in which only two cells are actually quoted:</p>

<p><font size="1" face="Courier" color="gray">54667,"""Tiny"" Tim",05/05/1980,M,20456.45,2347281749<br>
87896,John Doe,01/15/1960,M,234888.56,6482610982<br>
98798,"Luther, Lex",05/26/1940,M,9834.01,4566281737<br>
67491,Betty Boop,05/26/1932,F,34772.01,1902630722<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Using option 1, we no longer need to specify particular columns to act on because now only those cells are quoted that have embedded quotes or delimiters; therefore, we could have the filter act on all 6 columns by specifying a single range that covers all of them:</p>

<p><font size="1" face="Courier" color="gray">QuoteLines 1 6 /s6 /o1</font></p>

<p>The resulting output would be identical to the previous output in this instance.</p>

<p>Finally, option 2 is useful when you want only non-numeric* columns to be quoted. Specifying the QuoteLines filter using option 2,</p>

<p><font size="1" face="Courier" color="gray">QuoteLines 1 6 /s6 /o2</font></p>

<p>gives us this output:</p>

<p><font size="1" face="Courier" color="gray">54667,"""Tiny"" Tim","05/05/1980","M",20456.45,2347281749<br>
87896,"John Doe","01/15/1960","M",234888.56,6482610982<br>
98798,"Luther, Lex","05/26/1940","M",9834.01,4566281737<br>
67491,"Betty Boop","05/26/1932","F",34772.01,1902630722<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Now, those cells in each of the 6 columns that contain non-numeric values are quoted; however, the zip code and account number fields are not quoted because they only contain numeric characters. In this case, you could choose to manually specify each and every column to be quoted (using option 0) or you could use option 2 as shown above and simply add another QuoteLines filter (option 0) to handle quoting those columns that were not automatically handled by the first QuoteLines call. The entire pipe would be as follows:</p>

<p><font size="1" face="Courier" color="gray">SplitLines 8 21 33 37 48<br>
TrimLinesRight<br>
QuoteLines 1 6 /s6 /o2<br>
QuoteLines 1 1 6 6 /s6<br>
AppendStr ','<br>
JoinLines 6<br>
StripChars 1</font></p>

<p>Its execution gives us the desired output:</p>

<p><font size="1" face="Courier" color="gray">"54667","""Tiny"" Tim","05/05/1980","M",20456.45,"2347281749"<br>
"87896","John Doe","01/15/1960","M",234888.56,"6482610982"<br>
"98798","Luther, Lex","05/26/1940","M",9834.01,"4566281737"<br>
"67491","Betty Boop","05/26/1932","F",34772.01,"1902630722"<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Since the QuoteLines filter also works in-reverse, that is, it can unquote lines, you could use it to unquote any exceptional columns after having first quoted all columns using option 0.</p>

<p>For an example in which quoted, comma-delimited data is translated to fixed-width, see the ParseCSV filter.</p>

<a name="ReorderColumns"><h3>ReorderColumns</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ReorderColumns &lt;char pos&gt; &lt;char pos&gt; [&lt;char pos&gt; &lt;char pos&gt;...] /C /P&lt;char pos&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">re-arranges the column order of each line</font></p>

<p>The ReorderColumns filter re-arranges the column order of each line, allowing columns of data to be moved about, deleted or duplicated. Multiple character position pairs--each indicating a column of text to include in the output--can be specified in any order. The result is an aggregate of all such columns of text. If the /C switch is given then the second number in each pair is interpreted as a character count rather than an ending character position. This can be helpful if you know beforehand how wide each column is. If the /P switch is specified then the resulting aggregate is inserted back into each line at the given character position. This feature provides an alternative means of re-arranging the column order of the text.</p>

<p>Given the following text:</p>

<p><font size="1" face="Courier" color="gray">06/02/2002&nbsp;&nbsp;02:39p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Documents and Settings&nbsp;&nbsp;Archived<br>
10/28/2002&nbsp;&nbsp;10:16a&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Outlook Mail Messages&nbsp;&nbsp; Archived<br>
05/12/2003&nbsp;&nbsp;05:52p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Program Files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Archived<br>
04/14/2003&nbsp;&nbsp;08:36a&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;Trash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Archived<br>
04/01/2003&nbsp;&nbsp;01:55p&nbsp;&nbsp;&lt;dir&gt;&nbsp;&nbsp;WINNT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Archived<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Suppose you were only interested in viewing the date, time and description. The following pipe,</p>

<p><font size="1" face="Courier" color="gray">ReorderColumns 28 50 1 11 13 18</font></p>

<p>... will output just those fields:</p>

<p><font size="1" face="Courier" color="gray">Documents and Settings 06/02/2002 02:39p<br>
Outlook Mail Messages&nbsp;&nbsp;10/28/2002 10:16a<br>
Program Files&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;05/12/2003 05:52p<br>
Trash&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;04/14/2003 08:36a<br>
WINNT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;04/01/2003 01:55p<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<a name="ReplStr"><h3>ReplStr</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ReplStr &lt;find string&gt; &lt;replace string&gt; [&lt;find string&gt; &lt;replace string&gt;...] /B&lt;char pos&gt; /D&lt;delimiter&gt; /E&lt;char pos&gt; /I /P&lt;place holder&gt; /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">replaces character strings found in the text</font></p>

<p>The ReplStr filter replaces each occurrence of &lt;find string&gt; found within each line with &lt;replace string&gt;. Multiple string replacements can be performed per call. If the /I switch is specified the find string is searched without regard to its case. If the /R switch is specified the find string is treated as a regular expression pattern.</p>

<p>In addition to performing text replacements in which both the find and replace strings are specified as arguments, the ReplStr filter can also perform text replacements on an input line using a replace string that originates from the input line itself. If a /B switch is given, text will be extracted from the input line at the character position specified. This extracted text's ending position in the input line can be specified using the /E switch. As an alternative, you can omit the /E switch and by default, the text in the input line must be terminated (delimited) by a blank character. This delimiter character can be changed by specifying a /D switch.</p>

<p>Note: The &lt;delimiter&gt; is a single character and not a string; therefore, only the first character of a specified delimiter will be used.</p>

<p>As text is extracted from the input line itself and used as a replace string when a /B switch is specified, you might wonder what use is the replace string argument in this case? The answer is that it acts as a template to describe how the extracted text is used during the text replacement. For clarification of the replace string argument used as a template, see the last example below.</p>

<p>As a first example to illustrate the basic functionality of the ReplStr filter, given the following text,</p>

<p><font size="1" face="Courier" color="gray">Pyper rocks</font></p>

<p>... the following pipe,</p>

<p><font size="1" face="Courier" color="gray">ReplStr 'rocks' 'ROCKS!'</font></p>

<p>... produces:</p>

<p><font size="1" face="Courier" color="gray">Pyper ROCKS!</font></p>

<p>Because it's possible to replace a character string with one that contains an end-of-line, (\e) you can insert lines into the output stream using the ReplStr filter. For example, given the following text,</p>

<p><font size="1" face="Courier" color="gray">the,quick,brown,fox</font></p>

<p>... the pipe,</p>

<p><font size="1" face="Courier" color="gray">ReplStr ',' '\e'</font></p>

<p>... outputs:</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick<br>
brown<br>
fox</font></p>

<p>Although, lines can be inserted into the text stream by inserting end-of-lines it's not possible to replace end-of-lines since they cannot actually be found in an input line of text. Fortunately, there's a way around this by using the JoinLines filter. This technique can be used to replace not only the end-of-lines, but also strings that are adjacent to them.</p>

<p>For example, the following pipe uppercases any occurence of "the" that is located at the end of a line:</p>

<p><font size="1" face="Courier" color="gray">AppendStr '&lt;eol&gt;'<br>
JoinLines<br>
ReplStr 'the&lt;eol&gt;' 'THE&lt;eol&gt;' '&lt;eol&gt;' '\e'</font></p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">you can use the replstr filter<br>
to replace end-of-lines with the<br>
help of the joinlines filter</font></p>

<p>... the above pipe outputs the following:</p>

<p><font size="1" face="Courier" color="gray">you can use the replstr filter<br>
to replace end-of-lines with THE<br>
help of the joinlines filter</font></p>

<p>As you can see, only one "the" is uppercased but the other two are left unchanged as they are not at the end of a line.</p>

<p>Note: This is not how you would typically approach the problem of replacing strings at the end of lines. I show this only to illustrate that end-of-lines themselves can be referenced in a find string and thus be replaced or deleted (in fact, this is commonly done in Pyper). In practice, the above would be done using a regular expression:</p>

<p><font size="1" face="Courier" color="gray">ReplStr 'the$' 'THE' /r</font></p>

<p>As noted above, the ReplStr filter can perform text replacements using a replace string that originates from the input line itself. This feature is exploited in the "Create an Index" demo that is accessible via Pyper's About menu. Of relevance to this discussion are the following lines, including comments, from the middle of the pipe (Create An Index.pip):</p>

<p><font size="1" face="Courier" color="gray">; Distribute the page number across each line<br>
; to every word on that line:</font></p>

<p><font size="1" face="Courier" color="gray">ReplStr ' ' ':% ' /b1 /d':'</font></p>

<p><font size="1" face="Courier" color="gray">; Remove the page number and ":" at the head of each line:</font></p>

<p><font size="1" face="Courier" color="gray">DelChars 1 5</font></p>

<p>Format-wise, the text that is input to the ReplStr filter at this point in the pipe looks something like this (the number of words is reduced here for illustration purposes):</p>

<p><font size="1" face="Courier" color="gray">0001:Joseph Priestley March Old Style February<br>
0002:Early life and education Priestley was born<br>
0003:Priestley later wrote that the book that<br>
0004:Warrington Academy In Priestley moved to</font></p>

<p>Note: Each of these lines ends with a space.</p>

<p>When run through the above two filters, the 4-digt page number at the head of each line is "distributed" across the line to each word and then removed from the head of the line:</p>

<p><font size="1" face="Courier" color="gray">Joseph:0001 Priestley:0001 March:0001 Old:0001 Style:0001 February:0001<br>
Early:0002 life:0002 and:0002 education:0002 Priestley:0002 was:0002 born:0002<br>
Priestley:0003 later:0003 wrote:0003 that:0003 the:0003 book:0003 that:0003<br>
Warrington:0004 Academy:0004 In:0004 Priestley:0004 moved:0004 to:0004</font></p>

<p>In the actual demo, (Create An Index.pip) this resulting text is then further processed to form the word index, (which is beyond the scope of this example).</p>

<p>As noted earlier, when the ReplStr filter is used with the /B switch, the replace string argument is treated as a template. Here, in this example, the template is specified as ":% '. The "%" is a placeholder that will be replaced by the text that gets extracted from the input line. The result of this replacement is then used to replace any blanks that are found in the input line. On the first line for example, the text "0001" replaces the "%" in the template resulting in ":0001 ". This resulting string is then used to replace all blanks in the first line of the input text. The remaining input lines are handled accordingly.</p>

<p>Note: The placeholder can be changed using the /P switch.</p>

<a name="ReverseChars"><h3>ReverseChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ReverseChars [&lt;begin char pos&gt; &lt;end char pos&gt;]</font><br>
<font size="1">summary: </font><font size="1" color="gray">reverses the characters in each line of the input text</font></p>

<p>The ReverseChars filter reverses the characters in each line of the input text. If a range of character positions is specified, then just those characters will be reversed. The ReverseChars filter is mostly useful as a pre-filter for other filters. For example, given the following text,</p>

<p><font size="1" face="Courier" color="gray">brake pads 12.50<br>
brake drums 32.90<br>
spark plug wires 06.75<br>
radiator hose 05.49</font></p>

<p>suppose you wanted to insert a dollar sign, "$" ahead of the cost for each item. The InsStr filter alone can't help here because the character position of the cost varies from line to line. However, if the characters on each line were reversed, the dollar sign could then be inserted at column 6 for each line. The following pipe does exactly this and then it reverses the resulting text a second time in order to return it back to it's initial state:</p>

<p><font size="1" face="Courier" color="gray">ReverseChars<br>
InsStr 6 '$'<br>
ReverseChars</font></p>

<p>The result of its execution on the above text is as follows:</p>

<p><font size="1" face="Courier" color="gray">brake pads $12.50<br>
brake drums $32.90<br>
spark plug wires $06.75<br>
radiator hose $05.49</font></p>

<p>Note: The particular problem presented here is merely for demonstration. Were this problem actually encountered, you'd likely use the ReplStr filter and a regular expression to solve it.</p>

<a name="RightChars"><h3>RightChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">RightChars &lt;no of chars&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">returns the given number of characters from the end of each line of text</font></p>

<p>The RightChars filter outputs the specified right-most characters from each input line of text.</p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">Table, 123.45<br>
Chair, 061.22<br>
----+----1----+----2</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">RightChars 6</font></p>

<p>gives:</p>

<p><font size="1" face="Courier" color="gray">123.45<br>
061.22<br>
----+----1----+----2</font></p>

<p>See also LeftChars</p>

<a name="RotCharsLeft"><h3>RotCharsLeft</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">RotCharsLeft &lt;no of chars&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">rotates characters left given no of places</font></p>

<p>The RotCharsLeft filter rotates the characters in each line the specified number of characters to the left.</p>

<p>See also RotCharsRight and RotCharsToStr</p>

<a name="RotCharsRight"><h3>RotCharsRight</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">RotCharsRight &lt;no of chars&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">rotates characters right given no of places</font></p>

<p>The RotCharsRight filter rotates the characters in each line the specified number of characters to the right.</p>

<p>See also RotCharsLeft and RotCharsToStr</p>

<a name="RotCharsToStr"><h3>RotCharsToStr</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">RotCharsToStr &lt;string&gt; /I /N&lt;count&gt; /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">rotates each line until given string is at its beginning</font></p>

<p>The RotCharsToStr filter rotates the characters in each line left until the specified string is located at the beginning of the line. If the desired string is already located at the beginning of a line no rotation takes place. If a count is specified using the /N switch, that number of rotate-to-string operations is carried out. This enables you to target any ocurrence of a string that exists multiple times in a line being rotated. If the /I switch is specified the string is matched regardless of case. If the /R switch is specified the string is treated as a regular expression pattern.</p>

<p>As an example, suppose you wanted to insert a "$" ahead of the item cost in each line:</p>

<p><font size="1" face="Courier" color="gray">64339; Table, w/ glass top; 123.45; Furniture Dept.<br>
94732; Chair, high back w/ cushion; 61.22; Furniture Dept.</font></p>

<p><font size="1" face="Courier" color="gray">AppendStr '&lt;eol&gt;'<br>
RotCharsToStr ';' /n2<br>
InsStr 3 '$'<br>
RotCharsToStr '&lt;eol&gt;'<br>
DelChars 1 5</font></p>

<p>Its execution results in the following:</p>

<p><font size="1" face="Courier" color="gray">64339; Table, w/ glass top; $123.45; Furniture Dept.<br>
94732; Chair, high back w/ cushion; $61.22; Furniture Dept.</font></p>

<p>One use of the RotCharsToStr filter that isn't immediately obvious is to have it rotate not just each line individually but the entire input text. This is an extremely powerful editing technique.&nbsp;&nbsp;For an in-depth example see the demo, "Edit HTML Files". What follows is a more concise example.</p>

<p>Given the following lines of text:</p>

<p><font size="1" face="Courier" color="gray">The RotCharsToStr filter<br>
can be used to rotate<br>
the lines in the text.</font></p>

<p>Suppose you wanted to rotate them upward so that the second line ended up at the top. The following pipe makes use of the RotCharsToStr filter to accomplish this:</p>

<p><font size="1" face="Courier" color="gray">AppendStr '&lt;eol&gt;'<br>
JoinLines<br>
RotCharsToStr '&lt;eol&gt;'<br>
RotCharsLeft 5<br>
StripChars 5<br>
ReplStr '&lt;eol&gt;' '\e'</font></p>

<p>Its execution results in the following:</p>

<p><font size="1" face="Courier" color="gray">can be used to rotate<br>
the lines in the text.<br>
The RotCharsToStr filter</font></p>

<p>See also RotCharsLeft and RotCharsRight</p>

<a name="SetDebugOn"><h3>SetDebugOn</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">SetDebugOn</font><br>
<font size="1">summary: </font><font size="1" color="gray">configures pipe debugging on</font></p>

<p>The SetDebugOn command turns debugging on for all subsequent filters until the SetDebugOff command is encountered.</p>

<p>See also SetDebugOff</p>

<a name="SetDebugOff"><h3>SetDebugOff</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">SetDebugOff</font><br>
<font size="1">summary: </font><font size="1" color="gray">configures pipe debugging off</font></p>

<p>The SetDebugOff command terminates filter debugging that was initiated prior by the SetDebugOn command.</p>

<p>See also SetDebugOn</p>

<a name="ShiftChars"><h3>ShiftChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">ShiftChars &lt;char pos&gt; &lt;string&gt; [&lt;char pos&gt; &lt;string&gt;...] /I /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">shifts text into specified character positions</font></p>

<p>The ShiftChars filter shifts text into specified character positions, (deleting any text that is shifted over). It will shift the text either to the left or to the right as necessary. The first parameter is the character position to shift the text to and the second parameter specifies the string to be shifted. Any number of position/string pairs can be specified but the character positions must be in ascending order. If the /I switch is specified the case of the strings is ignored. If the /R switch is specified the strings are treated as a regular expression patterns.</p>

<p>The ShiftChars filter is useful for forcing text into a specific column position so that subsequent filters can operate based on that assumption. For example, given the following data delimited by commas,</p>

<p><font size="1" face="Courier" color="gray">John L. Doe,42,Miami,FL<br>
Frank N. Stein,20,Los Angeles,CA<br>
Norma Lee,16,Austin,TX<br>
----+----1----+----2----+----3----+----4</font></p>

<p>... the following pipe,</p>

<p><font size="1" face="Courier" color="gray">ShiftChars 15 ',' 18 ',' 30 ','<br>
DelChars 15 1 18 1 30 1</font></p>

<p>... will output the data fixed-width:</p>

<p><font size="1" face="Courier" color="gray">John L. Doe&nbsp;&nbsp; 42Miami&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FL<br>
Frank N. Stein20Los AngelesCA<br>
Norma Lee&nbsp;&nbsp;&nbsp;&nbsp; 16Austin&nbsp;&nbsp;&nbsp;&nbsp; TX<br>
----+----1----+----2----+----3----+----4</font></p>

<p>Here, the same string, (a comma) is specified repeatedly but each specified string could be different.</p>

<p>Note: The above is not a particularly good way to transform CSV data to fixed-width. This is partly because you don't necessarily know beforehand what column to shift the commas to (that will accomodate the widest field for that column). The preferred approach would be to use the ParseCSV filter along with the PadLinesRight and JoineLines filters. See ParseCSV for an example.</p>

<p>Another use for ShiftChars is to simply delete text at some given character position up to a given string (a function that the DelCharsToStr also performs). For example, suppose you wanted only the third and last fields of the following lines of data:</p>

<p><font size="1" face="Courier" color="gray">2010/08/15, 12:15:48.030, 983900002, A, 34.45.22.65, N47, 0003535, Driver Failure<br>
2010/08/15, 12:16:01.473, 0872303, A, 34.45.22.65, N47, 0003535, Bad Drive at 45453:883<br>
2010/08/15, 12:16:02.229, 740900002, A, 34.45.22.65, N226, 0003535, System Configured<br>
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9</font></p>

<p>This can be achieved using ShiftChars by making use of the comma characters. The following pipe,</p>

<p><font size="1" face="Courier" color="gray">ShiftChars 1 ',' 1 ',' 13 ',' 13 ',' 13 ',' 13 ',' 13 ','<br>
DelChars 1 2</font></p>

<p>... delivers the goods:</p>

<p><font size="1" face="Courier" color="gray">983900002 , Driver Failure<br>
0872303&nbsp;&nbsp; , Bad Drive at 45453:883<br>
740900002 , System Configured<br>
----+----1----+----2----+----3----+----4</font></p>

<p>Here, the first two commas are shifted, one after the other, into character position 1. This effectively wipes out the first two fields of data. Then, the next five commas are shifted into position 13, effectively removing fields 4 through 7.</p>

<p>Note: When a string is referenced multiple times by the ShiftChars filter, each reference refers to the next "unshifted" occurrence of that string found in the input text. Once an occurrence of that string in the input text has been referenced it can no longer be referenced again by the same ShiftChars filter.</p>

<p>See also DelCharsToStr</p>

<a name="SortLines"><h3>SortLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">SortLines /P&lt;char pos&gt; /R</font><br>
<font size="1">summary: </font><font size="1" color="gray">sorts the text</font></p>

<p>The SortLines filter outputs the text sorted. The /P switch can be used to specify which character position to sort the text on. By default, the text is sorted on character position 1 (that is, the sort is performed on the entire line of text). The /R switch causes the input text to be sorted in reverse order.</p>

<p>Given the text,</p>

<p><font size="1" face="Courier" color="gray">the<br>
quick brown<br>
fox<br>
jumped<br>
over the lazy<br>
dog and<br>
the lazy<br>
dog<br>
didn't even bark</font></p>

<p>...the following pipe parses it onto separate lines, inserts a line number ahead of each word and then sorts the text based on the words, not the line numbers:</p>

<p><font size="1" face="Courier" color="gray">ParseWords<br>
InsStr 1 ' '<br>
InsLineNo /w2 /z<br>
SortLines /p4</font></p>

<p>Its execution results in the following:</p>

<p><font size="1" face="Courier" color="gray">10 and<br>
16 bark<br>
03 brown<br>
14 didn't<br>
09 dog<br>
13 dog<br>
15 even<br>
04 fox<br>
05 jumped<br>
12 lazy<br>
08 lazy<br>
06 over<br>
02 quick<br>
11 the<br>
01 the<br>
07 the</font></p>

<a name="SpliceFile"><h3>SpliceFile</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">SpliceFile &lt;file name&gt; /D&lt;delimiter&gt; /M</font><br>
<font size="1">summary: </font><font size="1" color="gray">combines text from a text file to the input text</font></p>

<p>The SpliceFile filter extends each line of the input text by appending to it its corresponding line from the splice file. In other words, the two text sources are "spliced" together. If either text source has more lines of text than the other, the extra lines are simply appended to the output and therefore, the input text and the splice file should contain the same number of lines of text. If a delimiter string is specified using the /D switch, it will be appended to each line of the input text ahead of the spliced text. If the /M (merge) switch is specified the text from the splice file is added to the end of the input text rather than spliced line-by-line. Note that the &lt;file name&gt; parameter must be a single-quoted string as it can contain blanks.</p>

<p>Given the following input text,</p>

<p><font size="1" face="Courier" color="gray">test.txt<br>
rev.txt<br>
list1.txt</font></p>

<p>... and the following text in LIST2.TXT,</p>

<p><font size="1" face="Courier" color="gray">05-26-99&nbsp;&nbsp;5:19p<br>
05-26-99&nbsp;&nbsp;5:22p<br>
05-26-99&nbsp;&nbsp;5:30p</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">PadLinesRight ' '<br>
AppendStr ' '<br>
SpliceFile 'c:\list2.txt'</font></p>

<p>will output the following:</p>

<p><font size="1" face="Courier" color="gray">test.txt&nbsp;&nbsp;05-26-99&nbsp;&nbsp;5:19p<br>
rev.txt&nbsp;&nbsp; 05-26-99&nbsp;&nbsp;5:22p<br>
list1.txt 05-26-99&nbsp;&nbsp;5:30p</font></p>

<a name="SplitLines"><h3>SplitLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">SplitLines &lt;char pos&gt; [&lt;char pos&gt;...]</font><br>
<font size="1">summary: </font><font size="1" color="gray">splits each line at the given character position(s)</font></p>

<p>The SplitLines filter splits each line at the given character position(s). Multiple character positions can be specified where splitting is to occur but they must be in ascending order.</p>

<p>Suppose for example that you wanted to reform the following list of items so that they formed four columns instead of three:</p>

<p><font size="1" face="Courier" color="gray">01 ONE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;02 TWO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;03 THREE,<br>
04 FOUR,&nbsp;&nbsp;&nbsp;&nbsp; 05 FIVE,&nbsp;&nbsp;&nbsp;&nbsp; 06 SIX,<br>
07 SEVEN,&nbsp;&nbsp;&nbsp;&nbsp;08 EIGHT,&nbsp;&nbsp;&nbsp;&nbsp;09 NINE,<br>
10 TEN,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11 ELEVEN,&nbsp;&nbsp; 12 TWELVE,<br>
13 THIRTEEN, 14 FOURTEEN, 15 FIFTEEN,<br>
----+----1----+----2----+----3----+----4</font></p>

<p>To do this, you would first need to get each number and its associated comment onto a separate line by itself. One way to do this is using the SplitLines filter:</p>

<p><font size="1" face="Courier" color="gray">SplitLines 14 27</font></p>

<p>Executing this pipe results in a single "column" of data:</p>

<p><font size="1" face="Courier" color="gray">01 ONE,<br>
02 TWO,<br>
03 THREE,<br>
04 FOUR,<br>
05 FIVE,<br>
06 SIX,<br>
07 SEVEN,<br>
08 EIGHT,<br>
...</font></p>

<p>Adding PadLinesRight and JoinLines filters, we now have this:</p>

<p><font size="1" face="Courier" color="gray">SplitLines 14 27<br>
PadLinesRight ' ' /w15<br>
JoinLines 4</font></p>

<p>Its execution results in the desired four columns of data:</p>

<p><font size="1" face="Courier" color="gray">01 ONE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;02 TWO,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;03 THREE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;04 FOUR,<br>
05 FIVE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 06 SIX,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;07 SEVEN,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;08 EIGHT,<br>
09 NINE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 TEN,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11 ELEVEN,&nbsp;&nbsp;&nbsp;&nbsp; 12 TWELVE,<br>
13 THIRTEEN,&nbsp;&nbsp; 14 FOURTEEN,&nbsp;&nbsp; 15 FIFTEEN,<br>
----+----1----+----2----+----3----+----4----+----5----+----6</font></p>

<p>Note: Other alternatives to using SplitLines may include ParseWords, InsStr, ReplStr and ParseCSV.</p>

<a name="StripChars"><h3>StripChars</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">StripChars &lt;no of chars&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">deletes a given number of characters from the end of each line</font></p>

<p>The StripChars filter deletes a given number of characters from the end of each line. For an example of its use, see the JoinLines filter.</p>

<p>See also DelChars</p>

<a name="SubValues"><h3>SubValues</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">SubValues &lt;char pos&gt; &lt;char pos&gt; /I&lt;ins char pos&gt; /W&lt;width&gt; /D&lt;decimals&gt; /S</font><br>
<font size="1">summary: </font><font size="1" color="gray">subtracts two numbers found on each line of text</font></p>

<p>The SubValues filter subtracts two numbers found in each input line and outputs the result of the subtraction per each line. The two required parameters specify at what character positions the numbers involved in the subtraction are located and in each case must point at the leftmost digit of the number or at the white space prior to it. If the /I switch is specified, the result of the subtraction is inserted back into the line of text at the specified character position rather than simply being output alone, one per line. The /W switch determines the width of the resulting numeric values and the /D switch determines the number of decimal places displayed after the decimal point. If /S is specified, the resulting values will be output in scientific notation.</p>

<p>Given input text containing the two columns of numbers:</p>

<p><font size="1" face="Courier" color="gray">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8<br>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.75<br>
12.5&nbsp;&nbsp;&nbsp;&nbsp; 5.5<br>
----+----1----+----2----+----3</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">SubValues 1 10</font></p>

<p>outputs the result of each subtraction:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;6.00<br>
&nbsp;&nbsp;7.25<br>
&nbsp;&nbsp;7.00<br>
----+----1----+----2----+----3</font></p>

<p>Adding the /I switch,</p>

<p><font size="1" face="Courier" color="gray">SubValues 1 10 /i20</font></p>

<p>causes the result of the subtraction to be inserted back into each line, in this case at character position 20:</p>

<p><font size="1" face="Courier" color="gray">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.00<br>
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.25<br>
12.5&nbsp;&nbsp;&nbsp;&nbsp; 5.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7.00<br>
----+----1----+----2----+----3</font></p>

<a name="TopLines"><h3>TopLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">TopLines &lt;no of lines&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">outputs the given number of lines from the beginning of the input text</font></p>

<p>The TopLines filter outputs the given number of lines from the top of the input text. It can be used in conjunction with the BottomLines filter to return a range of lines from the middle of the input text. See the BottomLines filter for an example of how this is done. A range of lines can also be output using LinesByPos.</p>

<p>See also BottomLines, LinesByPos</p>

<a name="TotalColumns"><h3>TotalColumns</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">TotalColumns &lt;char pos&gt; [&lt;char pos&gt;...] /W&lt;width&gt; /D&lt;decimals&gt; /A /S</font><br>
<font size="1">summary: </font><font size="1" color="gray">totals columns of numeric values</font></p>

<p>For each character position specified, the TotalColumns filter totals the numeric values found on all input lines at that character position. A specified character position does not have to point directly at a value's first digit, but can point to the white space ahead of the value as well. The output from the TotalColumns filter is a single line of text that contains the totals of all columns specified. The totals are written to this output line at the character positions specified. The /W switch determines the width of each numeric total and the /D switch determines the number of decimal places displayed after the decimal point. If the /A switch is specified the line of totals is output preceded by the input text lines themselves containing the values being totalled. The line of totals is thus appended to the end of the input text. If the /S switch is specified the totals will be formatted in scientific notation.</p>

<p>Given the following input text:</p>

<p><font size="1" face="Courier" color="gray">john&nbsp;&nbsp;&nbsp;&nbsp; 20.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.24<br>
fred&nbsp;&nbsp;&nbsp;&nbsp; 52.81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.42<br>
lisa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.06<br>
thomas&nbsp;&nbsp; 20.62&nbsp;&nbsp;&nbsp;&nbsp; 103.57<br>
tom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36.87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72.80<br>
----+----1----+----2----+----3----+----4</font></p>

<p>the pipe,</p>

<p><font size="1" face="Courier" color="gray">TotalColumns 9 20</font></p>

<p>outputs:</p>

<p><font size="1" face="Courier" color="gray">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;138.58&nbsp;&nbsp;&nbsp;&nbsp; 214.09<br>
----+----1----+----2----+----3----+----4</font></p>

<p>If the decimal points of all the values in a column are lined-up as they are in this example, you generally want the resulting total's decimal point to line-up as well. The location of a column's total depends on both its starting character position specified and on the setting of the numeric width, (which can be overridden by using the /W switch). In this example the width is assumed to be the standard default of 6 therefore to have the resulting totals (their decimal points) line up properly with their respective columns, the first total's character position must be specified here as 9 instead of 10. In general, a total's starting character position desired is determined according to the formula:</p>

<p>&lt;Total's Starting Char Pos&gt; = &lt;Column's Right-most Char Pos&gt; - &lt;Numeric Width&gt; + 1</p>

<p>To create reports that total both horizontally and vertically, you can use the TotalColumns filter in conjunction with the AddValues filter. Here, we use the /A (append) switch with the TotalColumns filter:</p>

<p><font size="1" face="Courier" color="gray">AddValues 10 20 /i30<br>
TotalColumns 9 20 30 /a</font></p>

<p>The result is as follows:</p>

<p><font size="1" face="Courier" color="gray">john&nbsp;&nbsp;&nbsp;&nbsp; 20.00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.24&nbsp;&nbsp;&nbsp;&nbsp; 32.24<br>
fred&nbsp;&nbsp;&nbsp;&nbsp; 52.81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6.42&nbsp;&nbsp;&nbsp;&nbsp; 59.23<br>
lisa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.06&nbsp;&nbsp;&nbsp;&nbsp; 27.34<br>
thomas&nbsp;&nbsp; 20.62&nbsp;&nbsp;&nbsp;&nbsp; 103.57&nbsp;&nbsp;&nbsp;&nbsp;124.19<br>
tom&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36.87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;72.80&nbsp;&nbsp;&nbsp;&nbsp;109.67<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;138.58&nbsp;&nbsp;&nbsp;&nbsp; 214.09&nbsp;&nbsp;&nbsp;&nbsp;352.67<br>
----+----1----+----2----+----3----+----4</font></p>

<a name="TrimLines"><h3>TrimLines</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">TrimLines</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes leading and trailing white space from each line of text</font></p>

<p>The TrimLines filter simply combines both the TrimLinesLeft and TrimLinesRight filters into one. It removes both leading and trailing white space characters from each line of text.</p>

<p>See also TrimLinesLeft, TrimLinesRight.</p>

<a name="TrimLinesLeft"><h3>TrimLinesLeft</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">TrimLinesLeft</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes leading white space from each line of text</font></p>

<p>The TrimLinesLeft filter removes all leading blanks and tabs from the front of each line.</p>

<p>See also TrimLinesRight, TrimLines.</p>

<a name="TrimLinesRight"><h3>TrimLinesRight</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">TrimLinesRight</font><br>
<font size="1">summary: </font><font size="1" color="gray">removes trailing white space from each line of text</font></p>

<p>The TrimLinesRight filter removes all trailing blanks and tabs from the end of each line.</p>

<p>See also TrimLinesLeft, TrimLines.</p>

<a name="UpperCase"><h3>UpperCase</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">UpperCase</font><br>
<font size="1">summary: </font><font size="1" color="gray">converts lowercase characters to uppercase</font></p>

<p>The UpperCase filter converts lowercase characters to uppercase.</p>

<p>See also LowerCase</p>

<a name="WrapText"><h3>WrapText</h3></a>

<p><font size="1">syntax: </font><font face="Courier" size="1" color="gray">WrapText &lt;char pos&gt; /B&lt;break chars&gt; /J&lt;%jaggedness&gt;</font><br>
<font size="1">summary: </font><font size="1" color="gray">wraps text at given character position</font></p>

<p>The WrapText filter wraps the text at the given character position. By default, lines are broken at spaces only. Use the /B switch to provide a string containing additional break characters. For example, the string "-" would cause hyphens to be considered as break characters in addition to spaces.</p>

<p>By default, break characters will be used that are within 25% of the end of a line (thus allowing lines to be 25% jagged). You can change this by specifying a different percentage value using the /J switch.</p>

<p>To illustrate the WrapText filter, suppose you had the following text,</p>

<p><font size="1" face="Courier" color="gray">If you allow 100% jaggedness, then the algothithm will favor breaking the<br>
line even at a blank (or break char.) that it finds located near the<br>
text's left margin, thus possibly resulting in "loose" lines that contain<br>
just a word or two.&nbsp;&nbsp;If set to 0%, no blank or break character found will<br>
be used as a break point and instead, the line will simply be broken at<br>
the margin (hence 0% jaggedness).<br>
----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8</font></p>

<p>... and you wanted it to be wrapped at character position 30. This can be accomplished using the following pipe:</p>

<p><font size="1" face="Courier" color="gray">TrimLines<br>
AppendStr ' '<br>
JoinLines<br>
WrapText 30</font></p>

<p>Since the input text is already on multiple lines, the first three filters are needed to transform it into a single line. Then, the WrapText filter, wraps the text as desired:</p>

<p><font size="1" face="Courier" color="gray">If you allow 100% jaggedness,<br>
then the algothithm will<br>
favor breaking the line even<br>
at a blank (or break char.)<br>
that it finds located near<br>
the text's left margin, thus<br>
possibly resulting in "loose"<br>
lines that contain just a<br>
word or two.&nbsp;&nbsp;If set to 0%,<br>
no blank or break character<br>
found will be used as a break<br>
point and instead, the line<br>
will simply be broken at the<br>
margin (hence 0% jaggedness).<br>
----+----1----+----2----+----3----+----4</font></p>

